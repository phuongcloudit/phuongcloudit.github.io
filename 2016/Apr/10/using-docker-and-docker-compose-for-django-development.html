<!DOCTYPE html><title>Using Docker (and Docker Compose) for Django development - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Gần đây, khái niệm ảo hóa sử dụng container được nhắc đến khá nhiều. Và Docker cũng đang nổi lên như một hiện tượng và được rất nhiều người sử dụng. Trong bài viết này, tôi sẽ đi vào tìm hiểu và thực hành sử dụng Docker cho dự án …"> <meta name=keywords content="Python, Django, Docker, Docker Compose, DevOps, virtualisation, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Using Docker (and Docker Compose) for Django development - manhhomienbienthuy's space"> <meta name=twitter:description content="Gần đây, khái niệm ảo hóa sử dụng container được nhắc đến khá nhiều. Và Docker cũng đang nổi lên như một hiện tượng và được rất nhiều người sử dụng. Trong bài viết này, tôi sẽ đi vào tìm hiểu và thực hành sử dụng Docker cho dự án …"> <meta name=twitter:image content=/https://i.imgur.com/LOdBGj3.png> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html class=current> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Using Docker (and Docker Compose) for Django development </h1> <div class=meta> Posted in <a href=/category/general.html>General</a> on April 10, 2016 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2016/Apr/10/using-docker-and-docker-compose-for-django-development.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/LOdBGj3.png alt="Using Docker (and Docker Compose) for Django development"> <p>Gần đây, khái niệm ảo hóa sử dụng container được nhắc đến khá nhiều. Và Docker cũng đang nổi lên như một hiện tượng và được rất nhiều người sử dụng. Trong bài viết này, tôi sẽ đi vào tìm hiểu và thực hành sử dụng Docker cho dự án Django xem sao.</p> <h1 id=tai-sao-lai-dung-docker>Tại sao lại dùng Docker<a class=headerlink href=#tai-sao-lai-dung-docker title="Permanent link">&para;</a></h1> <p>Nói chung tôi là người đơn giản. Tôi thấy Docker được nhiều người dùng quá. Mà nhiều người dùng thì chắc là tốt người ta mới dùng. Mà thứ tốt như vậy thì mình cũng nên dùng cho hợp vào trào lưu, kẻo lại bị lạc hậu so với người ta. Lý do chính đến với Docker của tôi đơn giản thế thôi.</p> <p>Ngoài ra, lý do phụ là tôi cũng đang có nhu cầu chạy Web trên một môi trường biệt lập với hệ thống. Đương nhiên, nếu không nhu cầu chạy máy ảo hay môi trường biệt lập gì thì bạn cũng chẳng cần nghĩ đến Docker làm gì cho mệt.</p> <p>Docker đã được quảng cáo rất nhiều. Bạn có thể đọc một số bài giới thiệu về Docker hoặc tham khảo thêm ở <a href=https://www.docker.com/ >trang chủ của Docker</a>. Tuy nhiên, tôi thấy phần lớn các bài viết mới chỉ là lý thuyết chung chung. Mà lý thuyết cần phải gắn liền với thực tiễn. Và bài viết này chính là phần "thực tiễn" đó.</p> <p>Nói ngắn gọn là chúng ta bắt tay vào thực hành luôn cho nóng. Ở đây, tôi sẽ sử dụng Docker để chạy ứng dụng Web viết bằng Django. Về cơ bản, các framework khác cũng sẽ tương tự như vậy.</p> <blockquote> <p>Trong bài viết này, tôi giả sử bạn đã có một project Django có sẵn trên máy. Nếu chưa có, bạn có thể xem qua <a href=https://docs.djangoproject.com/en/1.9/intro/ >tutorial của Django</a> và tạo ra một project như vậy. Chúng ta sẽ tìm hiểu cách cấu hình Docker trên project có sẵn đó.</p> </blockquote> <h1 id=cai-at>Cài đặt<a class=headerlink href=#cai-at title="Permanent link">&para;</a></h1> <p>Việc cài đặt Docker lên các hệ điều hành khác nhau, bạn có thể tham khảo <a href=https://docs.docker.com/engine/installation/ >ở đây</a>. Đây không phải là nội dung chính của bài viết này nên tôi sẽ không đi vào chi tiết.</p> <p>Tôi sử dụng Ubuntu 14.04 nên quá trình cài đặt trên máy của tôi có thể tóm tắt như sau:</p> <p>Update <code>apt</code> chuẩn bị cho quá trình cài đặt.</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo apt-get update
<span class=gp>$</span> sudo apt-get install apt-transport-https ca-certificates
<span class=gp>$</span> sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 <span class=se>\</span>
--recv-keys 58118E89F3A912897C070ADBF76221572C52609D
</pre></div> <p>Sửa file <code>/etc/apt/source.list.d/docker.list</code> với nội dung như sau.</p> <div class=codehilite><pre><span></span><span class=k>deb</span> <span class=s>https://apt.dockerproject.org/repo</span> <span class=kp>ubuntu-trusty</span> <span class=kp>main</span>
</pre></div> <p>Update danh sách package và xóa các phiên bản cũ</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo apt-get update
<span class=gp>$</span> sudo apt-get purge lxc-docker
</pre></div> <p>Cài đặt Docker</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo apt-get install docker-engine
</pre></div> <h1 id=su-dung-docker-e-phat-trien-django>Sử dụng docker để phát triển Django<a class=headerlink href=#su-dung-docker-e-phat-trien-django title="Permanent link">&para;</a></h1> <p>Thông thường, khi phát triển ứng dụng <a href=https://www.djangoproject.com/ >Django</a> nói riêng và các ứng dụng Python nói chung, chúng ta thường sử dụng môi trường ảo của Python (<a href=https://pypi.python.org/pypi/virtualenv>virtualenv</a> hoặc <a href=https://docs.python.org/3/library/venv.html>venv</a>). Mục đích của việc này là muốn tạo ra một môi trường biệt lập cho ứng dụng. Tách biệt nó khỏi phần còn lại của hệ thống, nhằm đảm bảo, việc phát triển ứng dụng của chúng ta không ảnh hưởng gì đến hệ thống cả.</p> <p>Tuy nhiên, các ứng dụng Web sử dụng Django hay bất kỳ framework nào khác, việc sử dụng môi trường ảo cho riêng Python là vẫn chưa đủ. Bởi vì ngoài các package Python cần thiết, còn rất nhiều thành phần khác nữa, ví dụ như cơ sở dữ liệu (PostgreSQL, MySQL, ...), cache (memcached, Redis, ...), v.v... Ngoài ra, nhiều khi chúng ta muốn cấu hình môi trường production để chạy thử trước khi chính thức vận hành ứng dụng, mà chưa có điều kiện hay nhu cầu thuê một server thật, chúng ta cần những giải pháp khác.</p> <p>Và giải pháp thông thường là sử dụng máy ảo. Chúng ta có thể sử dụng những chương trình như <a href=https://www.virtualbox.org/ >VirtualBox</a> hay <a href=http://www.vmware.com/ >VMWare</a> và cài đặt trên máy cá nhân một máy ảo Linux càng giống server càng tốt. Và chúng ta cũng sẽ đăng nhập vào đó, lấy code về cài đặt và cấu hình mọi thứ để trang Web của chúng ta chạy được.</p> <p>Vấn đề ở đây là, một máy ảo như vậy sẽ chiếm kha khá tài nguyên của hệ thống. Và với một máy tính cá nhân, thì nhiều khi chạy được máy ảo xong thì máy thật cũng không làm gì khác được. Ngoài ra, trong quá trình phát triển, mỗi khi chúng ta muốn cập nhật code mới, thì chúng ta phải làm một công việc khá lòng vòng đó là push code, sau đó login vào máy ảo và pull code về.</p> <p>Có một giải pháp khác là <a href=https://www.vagrantup.com/ >Vagrant</a> có thể giải quyết vấn đề update code trên máy ảo này. Nó có một cơ chế khá hay là cho phép đồng bộ hệ thống file và thư mục của dự án vào trong máy ảo nên code sẽ được cập nhật gần như ngay lập tức. Tuy nhiên, Vagrant cũng sử dụng dịch vụ bên thứ 3 như VirtualBox để chạy một máy ảo nên vấn đề tiêu tốn tài nguyên hệ thống vẫn chưa được giải quyết.</p> <p>Gần đây, Docker nổi lên và được cho là có thể giải quyết cả hai vấn đề trên. Nếu thực sự như vậy thì chúng ta có thể yên tâm sử dụng Docker trong công việc của mình rồi. Chúng ta sẽ thử dùng Docker xem nó có thể làm được những gì.</p> <h2 id=nhung-gi-chung-ta-can-khi-dung-docker>Những gì chúng ta cần khi dùng Docker<a class=headerlink href=#nhung-gi-chung-ta-can-khi-dung-docker title="Permanent link">&para;</a></h2> <p>Chúng ta có thể tóm tắt lại những yêu cầu khi ảo hóa như sau:</p> <ul> <li>Mã nguồn được biên tập ở máy thật và chạy ở máy ảo</li> <li>Việc cập nhật mã nguồn phải gần như ngay lập tức. Tức là mọi thay đổi mã nguồn ở máy thật phải xuất hiện trên máy ảo.</li> <li>Trang Web đang chạy phải có thể xem được từ bên ngoài.</li> </ul> <p>Docker cần phải giải quyết được 3 vấn đề trên trước đã, sau đó chúng ta mới xem xét đến vấn đề tài nguyên hệ thống.</p> <p>Yêu cầu thứ 3 khá đơn giản, có thể dễ dàng thực hiện bằng port forward. Yêu cầu biên tập và chạy mã nguồn ở hai nơi khác nhau cũng có thể giải quyết được. Chúng ta sẽ mount file và thư mục dự án vào trong container, và chúng ta có thể biên tập ở máy thật và chạy từ container.</p> <p>Có nhiều cách cấu hình các container khác nhau. Chúng ta sẽ dần dần tìm hiểu từng cách một.</p> <h2 id=build-tat-ca-trong-mot>Build tất cả trong một<a class=headerlink href=#build-tat-ca-trong-mot title="Permanent link">&para;</a></h2> <p>Giả sử server của bạn sẽ sử dụng hệ điều hành Ubuntu thì chúng ta sẽ sử dụng image Ubuntu để làm cơ sở cấu hình container, sau đó cấu hình thêm các thành phần cần thiết khác.</p> <p>Trước hết, chúng ta phải pull image <code>ubuntu</code> về máy:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker pull ubuntu
</pre></div> <p>Sau khi pull image này xong, chúng ta có thể tạo một container mới từ image này:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker run -i -t -p <span class=m>127</span>.0.0.1:8000:8000 ubuntu
</pre></div> <p>Lệnh trên sẽ tạo một container mới với port forward cổng <code>8000</code> của máy host (máy thật) vào cổng <code>8000</code> của container với những tùy chọn như sau:</p> <ul> <li><code>-i</code> kết nối với <code>stdin</code> và <code>stdout</code></li> <li><code>-t</code> khởi tạo một terminal</li> <li><code>-p</code> port forward</li> </ul> <p>Chúng ta cần thay đổi lệnh trên một chút và tạo container với lệnh sau cho phù hợp với mục tiêu của mình:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker run -i -t -p <span class=m>127</span>.0.0.1:8000:8000 <span class=se>\</span>
-v /home/django_project:/home/code ubuntu
</pre></div> <p>Lệnh trên sẽ tạo ra một container mới với cấu hình như sau:</p> <ul> <li>Port forward ở cổng <code>8000</code>. Như vậy, chúng ta có thể truy cập đến server chạy trong container qua cổng <code>8000</code> của máy thật.</li> <li>Thư mục <code>/home/django_project</code> được mount vào trong container ở đường dẫn <code>/home/code</code>. Điều đó có nghĩa là các file trong thư mục <code>/home/django_project</code> có thể truy cập được từ bên trong container ở <code>/home/code</code>.</li> </ul> <p>Hai điều trên chính là những gì chúng ta cần khi dùng Docker để phát triển Django. Bây giờ chúng ta có thể biên tập mã nguồn ở máy thật, chạy nó ở máy ảo và xem kết quả từ trình duyệt của mình. Mã nguồn được thực thi ở một môi trường biệt lập, một container của Docker.</p> <p>Vagrant cũng có cơ chế mount thư mục tương tự như vậy nhưng Vagrant sử dụng virtual machine nên khá tốn tài nguyên hệ thống, trong khi Docker nhẹ nhàng hơn rất nhiều.</p> <h3 id=cau-hinh-container>Cấu hình container<a class=headerlink href=#cau-hinh-container title="Permanent link">&para;</a></h3> <p>Với container đã được tạo ở trên, chúng ta sẽ được đăng nhập vào terminal của nó với dấu nhắc lệnh là <code>#</code>. Từ đây, chúng ta có thể cài đặt các thành phần cần thiết cho dự án của chúng ta như:</p> <ul> <li>Python</li> <li>PIP</li> <li>PostgreSQL</li> <li>Django và những thứ cần cho dự án khác</li> </ul> <p>Vậy là chúng ta có thể làm mọi thứ với container này như với một máy tính thông thường. Sau khi hoàn tất, bạn có thể thoát ra khỏi container với lệnh sau:</p> <div class=codehilite><pre><span></span><span class=gp>#</span> <span class=nb>exit</span>
</pre></div> <p>Tuy nhiên, ở đây cần phải lưu ý một chút. Nếu bạn không commit container, tất cả những gì bạn vừa làm sẽ không được lưu lại. Do đó, bạn cần phải commit. Trước hết, tìm ID của container với lệnh sau:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker ps -a
</pre></div> <p>Tìm container mà bạn vừa thao tác. Bạn có thể đặt tên cho nó khi commit:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker commit 31d58a70ae41 django_container
</pre></div> <p>Lệnh trên sẽ commit container bạn vừa thao tác và đặt tên cho nó là <code>django_container</code>. Thực ra, sau khi commit, bạn đã tạo ra một image mới cho container vừa rồi. Từ bây giờ, bạn cần khởi động container này để tiếp tục làm việc với dự án Django của mình, bạn có thể dùng lệnh như sau:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker start django_container
<span class=gp>$</span> sudo docker attach django_container
</pre></div> <p>Đơn giản vậy thôi. Nếu không thích container này nữa, bạn có thể xóa nó đi:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker rm django_container
</pre></div> <p>Nếu bạn muốn lưu trữ container mình đã tạo, bạn có thể sử dụng <a href=https://hub.docker.com/ >Docker hub</a>. Với Docker hub, bạn có thể thao tác <a href=https://docs.docker.com/mac/step_six/ >push, pull tương tự như với Github</a>. Ngoài ra, bạn còn có thể đóng gói container này thành một file <code>.tar</code> và chia sẻ nó với những developer khác. Cách làm cụ thể chúng ta sẽ tìm hiểu ở phần tiếp theo.</p> <h3 id=ong-goi-container>Đóng gói container<a class=headerlink href=#ong-goi-container title="Permanent link">&para;</a></h3> <p>Bạn có thể đóng gói toàn bộ container của mình (bao gồm code dự án, các môi trường Django, PostgreSQL, v.v...) vào một file <code>.tar</code>:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker <span class=nb>export</span> django_container &gt; /home/django_container.tar
</pre></div> <p>Sau khi có file này rồi, bạn có thể dễ dàng chia sẻ nó với các developer khác. Khi họ nhận được nó, họ sẽ dễ dàng khởi động đó với lệnh sau:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker load django_container &lt; /home/django_container.tar
</pre></div> <p>Việc gõ các lệnh để build và chạy các container có thể là một công việc nhàm chán. Đó chính là lúc bạn cần đến <a href=https://docs.docker.com/engine/reference/builder/ >Dockerfile</a>.</p> <p>Dockerfile chính là nơi bạn sẽ lưu các cấu hình cho container mà mình cần và có thể dễ dàng chạy container mà không cần phải nhớ những dòng lệnh khô khan và phức tạp. Dockerfile sẽ được sử dụng khá nhiều ở những phần tiếp theo. Nên theo tôi, bạn hãy xem qua nội dung của nó một chút trước khi chúng ta tiếp tục.</p> <h2 id=su-dung-docker-compose-cau-hinh-moi-truong-dev>Sử dụng Docker Compose cấu hình môi trường dev<a class=headerlink href=#su-dung-docker-compose-cau-hinh-moi-truong-dev title="Permanent link">&para;</a></h2> <p>Việc xây dựng toàn bộ môi trường chạy Web vào một container có thể chưa phải là điều bạn muốn. Bạn muốn chia môi trường này thành các module khác nhau để có thể tái sử dụng ở các dự án khác. Nhu cầu cơ bản nhất là tách biệt cơ sở dữ liệu và server Web để các dự án khác nhau có thể dùng chung một container cơ sở dữ liệu đó. <a href=https://docs.docker.com/compose/ >Docker Compose</a> có thể giúp bạn. Nó sẽ giúp chúng ta có thể cấu hình và chạy nhiều container cùng một lúc cho một dự án (hay bao nhiêu dự án thì tuỳ bạn).</p> <p>Trước hết, cần phải <a href=https://docs.docker.com/compose/install/ >cài đặt Docker Compose</a> để sử dụng. Có nhiều cách để làm việc này nhưng dễ dàng nhất theo tôi là sử dụng <code>pip</code>:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> pip install docker-compose
</pre></div> <p>Thông tin về Docker Compose, bạn có thể tham khảo thêm <a href=https://docs.docker.com/compose/ >ở đây</a>. Nói chung là tôi không muốn giới thiệu nhiều về nó, áp dụng nó vào thực tiễn sẽ là dễ hiểu nhất.</p> <p>Nói qua về ý tưởng trong phần này, chúng ta sẽ tạo ra hai container riêng biệt: một container để chạy Web và một container chứa cơ sở dữ liệu.</p> <p>Với dự án đang có, bạn tạo một <code>Dockerfile</code> mới để cấu hình cho container Web với nội dung như sau:</p> <div class=codehilite><pre><span></span><span class=k>FROM</span><span class=s> python:latest</span>
<span class=k>ENV</span> PYTHONUNBUFFERED <span class=m>1</span>
<span class=k>RUN</span> mkdir /code
<span class=k>WORKDIR</span><span class=s> /code</span>
<span class=k>ADD</span> requirements.txt /code/
<span class=k>RUN</span> pip install -r requirements.txt
</pre></div> <p>Nếu bạn chưa quen với Dockerfile, bạn có thể tham khảo thêm <a href=https://docs.docker.com/engine/userguide/dockerimages/#building-an-image-from-a-dockerfile>tài liệu này</a>.</p> <p>Dockerfile trên nhằm cấu hình một image mới từ image Python phiên bản mới nhất (3.5.1), sau đó thêm thư mục <code>/code</code> và cài đặt các package Python cần thiết đã được định nghĩa ở file <code>requirements.txt</code>. Container cho Web server sẽ được tạo ra từ image này.</p> <p>Dockerfile trên để cấu hình container Web, container cho cơ sở dữ liệu chúng ta không phải cấu hình image cho nó, chỉ cần sử dụng image <a href=https://hub.docker.com/_/postgres/ >postgres</a> chuẩn là đủ rồi.</p> <p>Tiếp theo, tạo file <code>docker-compose.yml</code> với nội dung:</p> <div class=codehilite><pre><span></span><span class=nt>version</span><span class=p>:</span> <span class=s>&#39;2&#39;</span>
<span class=nt>services</span><span class=p>:</span>
  <span class=nt>db</span><span class=p>:</span>
    <span class=nt>image</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">postgres</span>
  <span class=nt>web</span><span class=p>:</span>
    <span class=nt>build</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">.</span>
    <span class=nt>command</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">python manage.py runserver 0.0.0.0:8000</span>
    <span class=nt>volumes</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">.:/code</span>
    <span class=nt>ports</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class=s>&quot;8000:8000&quot;</span>
    <span class=nt>depends_on</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">db</span>
</pre></div> <p>File <code>docker-compose.yml</code> sẽ định nghĩa các container mà chúng ta cần. Hiện tại, chúng ta cần một container Web và một container cho cơ sở dữ liệu. Ngoài ra, file này còn một số thông tin cấu hình khác cho các container để chúng hoạt động theo đúng ý đồ của chúng ta. Bạn có thể tham khảo thêm <a href=https://docs.docker.com/compose/compose-file/ >ở đây</a> để biết thêm về cấu trúc của file này.</p> <p>Cấu hình trên khá đơn giản, chúng ta sẽ tạo ra 2 container. Container <code>postgres</code> là container cơ sở dữ liệu. Chúng ta sẽ sử dụng hoàn toàn cấu hình mặc định từ image <code>postgres</code> chuẩn là đủ. Container Web, sau khi cấu hình và cài đặt theo image được định nghĩa ở Dockerfile, chúng ta thêm một số cấu hình khác như port forward, mount thư mục và chạy server dev cho Django.</p> <p>Chúng ta chạy server cơ sở dữ liệu ở một container độc lập, nên chúng ta cần thay đổi settings để Django có thể kết nối đến nó. Settings mới sẽ tương tự như dưới đây:</p> <div class=codehilite><pre><span></span><span class=n>DATABASES</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>&#39;default&#39;</span><span class=p>:</span> <span class=p>{</span>
        <span class=s1>&#39;ENGINE&#39;</span><span class=p>:</span> <span class=s1>&#39;django.db.backends.postgresql&#39;</span><span class=p>,</span>
        <span class=s1>&#39;NAME&#39;</span><span class=p>:</span> <span class=s1>&#39;postgres&#39;</span><span class=p>,</span>
        <span class=s1>&#39;USER&#39;</span><span class=p>:</span> <span class=s1>&#39;postgres&#39;</span><span class=p>,</span>
        <span class=s1>&#39;HOST&#39;</span><span class=p>:</span> <span class=s1>&#39;db&#39;</span><span class=p>,</span>
        <span class=s1>&#39;PORT&#39;</span><span class=p>:</span> <span class=mi>5432</span><span class=p>,</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Vậy là quá trình cầu hình đã xong, việc cần làm còn lại chỉ đơn giản là tạo container từ cấu hình vừa rồi và khởi động chúng:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> docker-compose up
</pre></div> <p>Lần đầu tiên chạy lệnh này sẽ mất một chút thời gian do hệ thống phải pull các image về sau đó cài đặt và cấu hình các package khác. Những lần tiếp theo, thời gian khởi động sẽ nhanh hơn do chỉ cần đồng bộ các file và thư mục là đủ.</p> <p>Cuối cùng, nếu mọi chuyện bình thường, chúng ta có thể truy cập <a href=http://localhost:8000>http://localhost:8000</a>, kết quả sẽ như sau:</p> <p><img alt="django homepage" src=https://i.imgur.com/GIYWaT9.png></p> <p>Vậy là xong. Chúng ta build thành công môi trường dev cho dự án Django của chúng ta. Thậm chí container cơ sở dữ liệu còn có thể sử dụng ở nhiều dự án khác nhau nữa.</p> <h2 id=su-dung-docker-compose-cau-hinh-moi-truong-production>Sử dụng Docker Compose cấu hình môi trường production<a class=headerlink href=#su-dung-docker-compose-cau-hinh-moi-truong-production title="Permanent link">&para;</a></h2> <p>Có thể sẽ có lúc bạn muốn cấu hình thử môi trường production trên chính máy tính của mình. Phần này sẽ trình bày cách làm với Docker.</p> <p>Với việc sử dụng Docker Compose, việc cấu hình các container đã khá dễ dàng. Vì vậy, chúng ta sẽ tiếp tục sử dụng Docker và Docker Compose cấu hình thử môi trường production xem sao.</p> <p>Trước hết, bạn cần phải biết việc deploy Django đã. Nếu chưa biết, bạn có thể tham khảo thêm ở <a href=https://docs.djangoproject.com/en/1.9/howto/deployment/wsgi/ >hướng dẫn này</a>.</p> <p>Nói chung, khi deploy Django, stack của chúng ta sẽ bao gồm các thành phần sau:</p> <ul> <li>NGINX là server gateway đồng thời cũng là một reverse proxy.</li> <li>WSGI server (uWSGI hoặc gunicorn) chạy Django.</li> <li>Server cơ sở dữ liệu (PostgreSQL, MySQL, ...).</li> <li>Server khác nếu cần (memcached, Redis, ...)</li> </ul> <p>Chúng ta sẽ xây dựng các container của Docker tương tự như stack này. Stack của chúng ta được minh họa như hình dưới đây:</p> <p><img alt=django-stack src=https://i.imgur.com/MXCVipO.png></p> <p>Chúng ta có thể sử dụng <a href=https://uwsgi-docs.readthedocs.org/en/latest/ >uWSGI</a> hoặc <a href=http://gunicorn.org/ >gunicorn</a> để làm server WSGI chạy Django. uWSGI cho hiệu suất tốt hơn nhưng gunicorn dễ sử dụng hơn. Trong bài viết này, tôi quyết định sử dụng uWSGi, vừa là vì hiệu suất của nó, vừa là vì nó khó sử dụng nên chúng ta sẽ học được nhiều hơn.</p> <p>Bắt đầu cấu hình các container thôi. File <code>docker-compose.yml</code> sẽ có nội dung như dưới đây:</p> <div class=codehilite><pre><span></span><span class=nt>version</span><span class=p>:</span> <span class=s>&#39;2&#39;</span>
<span class=nt>services</span><span class=p>:</span>
  <span class=nt>db</span><span class=p>:</span>
    <span class=nt>restart</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
    <span class=nt>image</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">postgres</span>
    <span class=nt>volumes_from</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">data</span>
    <span class=nt>depends_on</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">data</span>
  <span class=nt>data</span><span class=p>:</span>
    <span class=nt>restart</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
    <span class=nt>image</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">postgres</span>
    <span class=nt>volumes</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/var/lib/postgresql</span>
    <span class=nt>command</span><span class=p>:</span> <span class=s>&quot;true&quot;</span>
  <span class=nt>nginx</span><span class=p>:</span>
    <span class=nt>restart</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
    <span class=nt>build</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">./nginx/</span>
    <span class=nt>ports</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class=s>&quot;80:80&quot;</span>
    <span class=nt>volumes</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">/www/static/</span>
    <span class=nt>volumes_from</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">web</span>
    <span class=nt>links</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">web:web</span>
    <span class=nt>depends_on</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">web</span>
  <span class=nt>web</span><span class=p>:</span>
    <span class=nt>restart</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">always</span>
    <span class=nt>build</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">.</span>
    <span class=nt>expose</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class=s>&quot;8000&quot;</span>
    <span class=nt>env_file</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">.env</span>
    <span class=nt>command</span><span class=p>:</span> <span class="l l-Scalar l-Scalar-Plain">uwsgi --http :8000 --module mysite.wsgi</span>
    <span class=nt>volumes</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">.:/code</span>
    <span class=nt>depends_on</span><span class=p>:</span>
      <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">db</span>
</pre></div> <p>Ở đây, chúng ta sẽ xây dựng các container như sau:</p> <p>Container <code>web</code> sẽ làm nhiệm vụ của server WSGI. Về cơ bản, container này khá giống cấu hình container Web của phần trước. Một số điểm khác biệt đó là nó không forward cổng <code>8000</code> mà chỉ "expose" cho container <code>nginx</code> mà thôi. Ngoài ra, nó sẽ sử dụng uWSGI để khởi động server cho Django.</p> <p>Container <code>nginx</code> sẽ làm nhiệm vụ của một reverse proxy, tiếp nhận các truy vấn từ người dùng và chuyển sang cho server WSGI. Ngoài ra, các file tĩnh (CSS, JavaScript, v.v..) sẽ không được Django phục vụ nữa, nhiệm vụ này cũng được chuyển cho NGINX.</p> <p>Ngoài ra chúng ta có một container cho PostgreSQL và một container để chứa dữ liệu. Việc tách dữ liệu ra lưu trữ ở một container riêng là để tránh sự phụ thuộc của dữ liệu và container <code>db</code>, đảm bảo rằng, dữ liệu sẽ vẫn còn nếu chúng ta thay <code>db</code> bằng một container khác.</p> <p>Ở đây, các container cho cơ sở dữ liệu rất đơn giản, chúng ta gần như sử dụng toàn bộ cấu hình từ image tiêu chuẩn. Container <code>web</code> khá giống phần trước nên tôi nghĩ không cần giải thích gì nhiều. Container <code>nginx</code> là phần mới nên tôi sẽ nói kỹ hơn về nó.</p> <h3 id=cau-hinh-container-nginx>Cấu hình container <code>nginx</code><a class=headerlink href=#cau-hinh-container-nginx title="Permanent link">&para;</a></h3> <p>Để cấu hình container <code>nginx</code>, chúng ta sẽ tạo một thư mục riêng cho nó. Bởi vì image chuẩn là chưa đủ, chúng ta cần cấu hình một image mới. Do đó, việc cấu hình này sẽ cần đến Dockerfile và file cấu hình cho server nên tổ chức chúng vào thư mục riêng sẽ quản lý dễ hơn.</p> <p>Dockerfile cho NGINX sẽ có nội dung như sau:</p> <div class=codehilite><pre><span></span><span class=k>FROM</span><span class=s> nginx</span>
<span class=k>ADD</span> django_site.conf /etc/nginx/conf.d/
</pre></div> <p>Cấu hình trên khá đơn giản. Chúng ta sẽ tạo một image mới từ image <code>nginx</code> chuẩn, và thêm cầu hình cho trang Web của dự án.</p> <p>Dưới đây là cấu hình cho server NGINX trở thành reverse proxy cho WSGI, đồng thời nó có nhiệm vụ phục vụ các file tĩnh (CSS, JavaScript, v.v...) ở đường dẫn <code>/static</code>.</p> <div class=codehilite><pre><span></span><span class=k>server</span> <span class=p>{</span>
    <span class=kn>listen</span>        <span class=mi>80</span><span class=p>;</span>
    <span class=kn>server_name</span>   <span class=s>vpyeu.local</span><span class=p>;</span>
    <span class=kn>charset</span>       <span class=s>utf-8</span><span class=p>;</span>

    <span class=kn>location</span> <span class=s>/static</span> <span class=p>{</span>
        <span class=kn>alias</span> <span class=s>/code/static</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
        <span class=kn>proxy_pass</span>        <span class=s>http://web:8000</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>Host</span>              <span class=nv>$host</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>X-Real-IP</span>         <span class=nv>$remote_addr</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>X-Forwarded-For</span>   <span class=nv>$proxy_add_x_forwarded_for</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Cấu hình này không có gì khó hiểu cả, nếu bạn đã từng làm việc với NGINX rồi. Ở đây tôi chọn <code>server_name</code> là <code>vpyeu.local</code> để tránh xung đột với config có sẵn của NGINX. Bạn có thể ghi đè lên config mặc định của NGINX (<code>/etc/nginx/nginx.conf</code>) cũng được. Chỉ có một lưu ý nhỏ là bạn cần sửa file <code>/etc/hosts</code> để có thể truy cập đến localhost thông qua <code>server_name</code>.</p> <p>Vậy là toàn bộ công việc cần làm đã xong. Docker Compose chỉ cần thêm một chút cầu hình cho container này từ image vừa được tạo ra như mount thư mục <code>static</code>, port forward, v.v nữa là xong. Bây giờ, chúng ta chỉ cần build và khởi động các container là xong. Chúng ta sẽ xem kết quả ở cổng <code>80</code> (<a href=http://vpyeu.local/ >http://vpyeu.local/</a>) chứ không phải ở cổng <code>8080</code> nữa.</p> <h2 id=chay-bash-ben-trong-container>Chạy bash bên trong container<a class=headerlink href=#chay-bash-ben-trong-container title="Permanent link">&para;</a></h2> <p>Làm theo tất cả những hướng dẫn ở trên, bạn có thấy thiếu gì không?</p> <p>Thực ra, đến đây, bạn chỉ có thể chạy Web Django khi chưa có app nào thôi. Bạn hoàn toàn chưa migrate database, chưa tạo user, và có thể sẽ còn vài thao tác cần khởi tạo nữa trước khi ứng dụng của chúng ta có thể hoạt động.</p> <p>Ví dụ, bạn muốn migrate database và tạo một superuser thì phải làm thế nào? Có một cách để làm việc này, đó là chạy lệnh sau để migrate:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> docker-compose run web python manage.py migrate
</pre></div> <p>Và dùng lệnh tương tự để tạo một admin:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> docker-compose run web python manage.py createsuperuser
</pre></div> <p>Tuy nhiên, cần lưu ý là mỗi lệnh như vậy sẽ tạo ra một container mới. Và may mắn cho chúng ta là nó sẽ cấu hình giống hệt container <code>web</code>, và do đó nó cũng kết nối đến cơ sở dữ liệu ở container <code>db</code>. Vì vậy, các lệnh <code>migrate</code> hay <code>createsuperuser</code> ở trên sẽ ghi vào cơ sở liệu này. Thế nên, chúng ta có thể sử dụng trang Web như bình thường.</p> <p>Nhưng một tác dụng phụ là chúng ta đã tạo ra 2 container thừa thãi chẳng để làm gì. Tất nhiên là bây giờ bạn có thể xóa chúng đi, rất đơn giản. Nhưng tại sao phải làm thế khi chúng ta có cách khác hay hơn?</p> <p>Thông thường, nếu là server thật, chúng ta phải ssh vào server đó và chạy các lệnh. Container của Docker cũng có cơ chế cho phép chúng ta làm điều tương tự.</p> <p>Chúng ta có thể chạy bash từ container với lệnh sau, sử dụng ID của container:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker <span class=nb>exec</span> -i -t 34f0d3e373f7 bash
</pre></div> <p>Hoặc sử dụng tên của container</p> <div class=codehilite><pre><span></span><span class=gp>$</span> sudo docker <span class=nb>exec</span> -i -t mysite_web bash
</pre></div> <p>Vậy là chúng ta đang "ở trong" bash của container là có thể thao tác tùy ý với container này. Chúng ta có thể dễ dàng migrate, tạo admin mà không cần tạo container nào khác.</p> <h2 id=update>Update<a class=headerlink href=#update title="Permanent link">&para;</a></h2> <h3 id=security>Security<a class=headerlink href=#security title="Permanent link">&para;</a></h3> <p>Vì những lý do về bảo mật, chúng ta chỉ nên port forward cho container <code>nginx</code> mà thôi. Các container khác chúng ta chỉ "expose" và liên kết các container với nhau thông qua <a href=https://docs.docker.com/compose/compose-file/#links>links</a>.</p> <p>Container <code>db</code> và cả container <code>data</code> để build từ image <code>postgres</code> chuẩn. Nếu chúng ta không chỉ định username và password thì bất cứ ai cũng có thể truy cập đến chúng. Ngoài ra, các dữ liệu như <code>SECRET_KEY</code>, hay <code>PASSWORD</code> của PostgreSQL chúng ta cần chuyển sang sử dụng biến môi trường thay vì hard code vào settings.</p> <p>Docker cho phép chúng ta dễ dàng thiết lập các biến môi trường thông qua <a href=https://docs.docker.com/compose/compose-file/#env-file>env_file</a>. Ví dụ, với container WSGI, chúng ta có thể cấu hình các biến môi trường như sau:</p> <div class=codehilite><pre><span></span><span class=nv>PYTHONBUFFERED</span><span class=o>=</span><span class=m>1</span>
<span class=nv>SECRET_KEY</span><span class=o>=</span>its-a-secret-to-everybody
<span class=nv>DB_NAME</span><span class=o>=</span>your-database-name
<span class=nv>DB_USER</span><span class=o>=</span>your-username
<span class=nv>DB_PASSWORD</span><span class=o>=</span>your-password
<span class=nv>DB_HOST</span><span class=o>=</span>db
<span class=nv>DB_PORT</span><span class=o>=</span><span class=m>5432</span>
</pre></div> <p>Lưu nội dung trên vào một file, ví dụ <code>.env</code>, chúng ta có thể dễ dàng cấu hình container các biến môi trường này:</p> <div class=codehilite><pre><span></span><span class=nt>env_file</span><span class=p>:</span>
  <span class="p p-Indicator">-</span> <span class="l l-Scalar l-Scalar-Plain">.env</span>
</pre></div> <p>Bây giờ, chúng ta cần thay đổi settings để lấy dữ liệu từ các biến môi trường này:</p> <div class=codehilite><pre><span></span><span class=n>SECRET_KEY</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;SECRET_KEY&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>)</span>
<span class=n>DATABASES</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>&#39;default&#39;</span><span class=p>:</span> <span class=p>{</span>
        <span class=s1>&#39;ENGINE&#39;</span><span class=p>:</span> <span class=s1>&#39;django.db.backends.postgresql&#39;</span><span class=p>,</span>
        <span class=s1>&#39;NAME&#39;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;DB_NAME&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>),</span>
        <span class=s1>&#39;USER&#39;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;DB_USER&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>),</span>
        <span class=s1>&#39;PASSWORD&#39;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;DB_PASSWORD&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>),</span>
        <span class=s1>&#39;HOST&#39;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;DB_HOST&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>),</span>
        <span class=s1>&#39;PORT&#39;</span><span class=p>:</span> <span class=n>os</span><span class=o>.</span><span class=n>environ</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;DB_PORT&#39;</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>),</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Chúng ta có thể làm điều tương tự với hai container <code>db</code> và <code>data</code>.</p> <p>Ngoài ra, chúng ta có thể thiết lập sử dụng HTTPS thay cho HTTP ngay trên chính Docker. Ví dụ, chúng ta có thể thay đổi config của NGINX như sau:</p> <div class=codehilite><pre><span></span><span class=k>server</span> <span class=p>{</span>
    <span class=kn>listen</span>        <span class=mi>80</span><span class=p>;</span>
    <span class=kn>server_name</span>   <span class=s>vpyeu.local</span><span class=p>;</span>
    <span class=kn>rewrite</span>       <span class=s>^/(.*)</span> <span class=s>https://</span><span class=nv>$host/$1</span> <span class=s>permanent</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>server</span> <span class=p>{</span>
    <span class=kn>listen</span>        <span class=mi>443</span> <span class=s>ssl</span><span class=p>;</span>
    <span class=kn>server_name</span>   <span class=s>vpyeu.local</span><span class=p>;</span>
    <span class=kn>charset</span>       <span class=s>utf-8</span><span class=p>;</span>
    <span class=kn>access_log</span>    <span class=s>/www/log/access.log</span> <span class=s>combined</span><span class=p>;</span>
    <span class=kn>error_log</span>     <span class=s>/www/log/error.log</span> <span class=s>error</span><span class=p>;</span>

    <span class=kn>ssl_certificate</span>       <span class=s>/www/ssl/ssl.crt</span><span class=p>;</span>
    <span class=kn>ssl_certificate_key</span>   <span class=s>/www/ssl/ssl.key</span><span class=p>;</span>

    <span class=kn>location</span> <span class=s>/static</span> <span class=p>{</span>
        <span class=kn>alias</span> <span class=s>/www/static</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kn>location</span> <span class=s>/media</span> <span class=p>{</span>
        <span class=kn>alias</span> <span class=s>/www/animals</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
        <span class=kn>proxy_pass</span>        <span class=s>http://web:8000</span><span class=p>;</span>
        <span class=kn>proxy_redirect</span>    <span class=no>off</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>Host</span>              <span class=nv>$http_host</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>X-Real-IP</span>         <span class=nv>$remote_addr</span><span class=p>;</span>
        <span class=kn>proxy_set_header</span>  <span class=s>X-Forwarded-For</span>   <span class=nv>$proxy_add_x_forwarded_for</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Config trên sẽ chuyển toàn bộ truy vấn sử dụng HTTP thành HTTPS. Từ bây giờ, chúng ta có thể thiếp lập thuộc tính <code>secure</code> cho cookie được rồi:</p> <div class=codehilite><pre><span></span><span class=n>CSRF_COOKIE_SECURE</span> <span class=o>=</span> <span class=kc>True</span>
<span class=n>SESSION_COOKIE_SECURE</span> <span class=o>=</span> <span class=kc>True</span>
</pre></div> <p>Cấu hình trên yêu cầu bạn phải có một SSL certificate để sử dụng HTTPS. Bạn có thể mua lấy một giấy phép như vậy. Tuy nhiên, ở localhost thì chúng ta chưa cần làm như vậy. Chúng ta có thể tạo ra một giấy phép SSL với <code>openssl</code> như sau:</p> <div class=codehilite><pre><span></span><span class=gp>$</span> openssl req -x509 -nodes -days <span class=m>365</span> -newkey rsa:2048 <span class=se>\</span>
-keyout mysite/nginx/ssl.key -out mysite/nginx/ssl.crt
</pre></div> <p>Chỉ có một vấn đề nhỏ, đó là khi tự tạo ra SSL certificate chúng ta sẽ gặp phải vấn đề sau:</p> <p><img alt="untrusted connection" src=https://i.imgur.com/d16m9ak.png></p> <p>Tất nhiên là bạn có thể bỏ qua vấn đề này để truy cập trang bình thường. Và kết quả sẽ như sau:</p> <p><img alt="django https" src=https://i.imgur.com/Q5ahUBq.png></p> <h3 id=su-dung-uwsgi_params>Sử dụng <code>uwsgi_params</code><a class=headerlink href=#su-dung-uwsgi_params title="Permanent link">&para;</a></h3> <p>Sau khi tham khảo một số nơi, và đặc biệt là <a href=http://uwsgi-docs.readthedocs.org/en/latest/Nginx.html>tài liệu của uWSGI</a>, thì uWSGI có hỗ trợ NGINX. Nên tôi nghĩ, chúng ta nên sử dụng <code>uwsgi_params</code> cho NGINX thì tốt hơn.</p> <p>Config của NGINX sẽ như sau:</p> <div class=codehilite><pre><span></span><span class=k>upstream</span> <span class=s>django</span> <span class=p>{</span>
    <span class=kn>server</span> <span class=n>web</span><span class=p>:</span><span class=mi>8000</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>server</span> <span class=p>{</span>
    <span class=kn>listen</span>        <span class=mi>80</span><span class=p>;</span>
    <span class=kn>server_name</span>   <span class=s>vpyeu.local</span><span class=p>;</span>
    <span class=kn>rewrite</span>       <span class=s>^/(.*)</span> <span class=s>https://</span><span class=nv>$host/$1</span> <span class=s>permanent</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>server</span> <span class=p>{</span>
    <span class=kn>listen</span>        <span class=mi>443</span> <span class=s>ssl</span><span class=p>;</span>
    <span class=kn>server_name</span>   <span class=s>vpyeu.local</span><span class=p>;</span>
    <span class=kn>charset</span>       <span class=s>utf-8</span><span class=p>;</span>
    <span class=kn>access_log</span>    <span class=s>/www/log/access.log</span> <span class=s>combined</span><span class=p>;</span>
    <span class=kn>error_log</span>     <span class=s>/www/log/error.log</span> <span class=s>error</span><span class=p>;</span>

    <span class=kn>ssl_certificate</span>       <span class=s>/www/ssl/ssl.crt</span><span class=p>;</span>
    <span class=kn>ssl_certificate_key</span>   <span class=s>/www/ssl/ssl.key</span><span class=p>;</span>

    <span class=kn>location</span> <span class=s>/static</span> <span class=p>{</span>
        <span class=kn>alias</span> <span class=s>/www/static</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kn>location</span> <span class=s>/media</span> <span class=p>{</span>
        <span class=kn>alias</span> <span class=s>/www/animals</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=kn>location</span> <span class=s>/</span> <span class=p>{</span>
        <span class=kn>include</span>       <span class=s>uwsgi_params</span><span class=p>;</span>
        <span class=kn>uwsgi_pass</span>    <span class=s>django</span><span class=p>;</span>
        <span class=kn>uwsgi_param</span>   <span class=s>Host</span>                <span class=nv>$http_host</span><span class=p>;</span>
        <span class=kn>uwsgi_param</span>   <span class=s>X-Real-IP</span>           <span class=nv>$remote_addr</span><span class=p>;</span>
        <span class=kn>uwsgi_param</span>   <span class=s>X-Forwarded-For</span>     <span class=nv>$proxy_add_x_forwarded_for</span><span class=p>;</span>
        <span class=kn>uwsgi_param</span>   <span class=s>X-Forwarded-Proto</span>   <span class=nv>$http_x_forwarded_proto</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Sử dụng <code>uwsgi_params</code> và <code>uwsgi_pass</code> có thể khiến bạn gặp lỗi 502 Bad Gateway khi kết nối từ container <code>nginx</code> sang container <code>web</code>. Khi đó, bạn cần thêm một chút cấu hình, nhất là thay đổi user chạy uWSGI. Vì cần cấu hình khá nhiều nên chúng ta sẽ viết chúng vào một file, <code>uwsgi.ini</code> với nội dung như sau:</p> <div class=codehilite><pre><span></span><span class=k>[uwsgi]</span>
<span class=c1># thư mục chứa mã nguồn Django</span>
<span class=na>chdir</span> <span class=o>=</span> <span class=s>/code</span>
<span class=c1># File wsgi của Django</span>
<span class=na>module</span> <span class=o>=</span> <span class=s>mysite.wsgi</span>
<span class=c1># Socket, để kết nối từ NGINX</span>
<span class=na>socket</span> <span class=o>=</span> <span class=s>0.0.0.0:8000</span>
<span class=c1># master</span>
<span class=na>master</span> <span class=o>=</span> <span class=s>true</span>
<span class=c1># số worker tối đa</span>
<span class=na>processes</span> <span class=o>=</span> <span class=s>10</span>
<span class=c1># thay đổi user để tránh lỗi 502</span>
<span class=na>chown-socket</span> <span class=o>=</span> <span class=s>www-data:www-data</span>
</pre></div> <p>Và thay đổi lệnh ở container <code>web</code> thành:</p> <div class=codehilite><pre><span></span><span class=go>uwsgi --ini uwsgi.ini</span>
</pre></div> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Docker thực sự cung cấp cho chúng ta một giải pháp mới cho công việc ảo hoá. Thay vì cách làm truyền thống là tạo phần cứng ảo và cài đặt nguyên một hệ điều hành lên đó, Docker đóng gói các container và chạy chúng trên chính máy thật. Nó thật tới mức, nếu Docker của bạn có chạy NGINX, ở ngay trên máy thật, chúng ta cũng thấy có tiến trình của NGINX đang chạy, giống hệt các tiến trình thông thường khác.</p> <p><img alt="docker process" src=https://i.imgur.com/G8JIcTV.png></p> <p>Docker container chạy trên máy thật và chia sẻ tài nguyên với chính máy thật, nên hoạt động nhẹ nhàng hơn hẳn các phương pháp ảo hoá khác. Ngoài ra, việc khởi động và tắt một container cũng rất nhanh chóng. Như trường hợp trên của chúng ta, chúng ta đang chạy cùng một lúc tới 4 container mà tài nguyên hệ thống cũng chưa tốn mấy.</p> <p><img alt="docker resource" src=https://i.imgur.com/mzFIMoo.png></p> <p>Thử tưởng tượng điều gì xảy ra nếu chúng ta chạy 4 máy ảo trên VirtualBox cùng một lúc. Tôi tin rằng , ngay cả khi chỉ cung cấp cho máy ảo cấu hình tối thiểu, máy tính của chúng ta sẽ tốn một lượng tài nguyên không nhỏ, và có lẽ, phần còn lại chẳng còn đủ để chúng ta code gì nữa.</p> <p>Docker là một giải pháp mà chúng ta có thể dùng khi cần đến ảo hoá trong các project nói chung, không nhất định là project Django.</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#Python</span> <span>#Django</span> <span>#Docker</span> <span>#Docker Compose</span> <span>#DevOps</span> <span>#virtualisation</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2016/May/12/using-amd-and-requirejs-to-modularize-large-javascript-project.html> Newer Post </a> </span> <span class=older-link> <a href=/2016/Mar/28/understanding-and-mastering-javascripts-this-keyword.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>