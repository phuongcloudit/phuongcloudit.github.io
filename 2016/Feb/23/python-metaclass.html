<!DOCTYPE html><title>Python metaclass - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Metaclass là một chủ đề khá ít người đề cập của Python. Một phần có lẽ bởi vì nó cũng ít được sử dụng, mà một phần lý do bởi vì Python cũng ít có tài liệu về chủ đề này. Trong bài viết này, tôi sẽ giới thiệu những …"> <meta name=keywords content="Python, metaclass, fundamental, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Python metaclass - manhhomienbienthuy's space"> <meta name=twitter:description content="Metaclass là một chủ đề khá ít người đề cập của Python. Một phần có lẽ bởi vì nó cũng ít được sử dụng, mà một phần lý do bởi vì Python cũng ít có tài liệu về chủ đề này. Trong bài viết này, tôi sẽ giới thiệu những …"> <meta name=twitter:image content=/https://i.imgur.com/HBnf0wV.png> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Python metaclass </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on February 23, 2016 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2016/Feb/23/python-metaclass.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/HBnf0wV.png alt="Python metaclass"> <p>Metaclass là một chủ đề khá ít người đề cập của Python. Một phần có lẽ bởi vì nó cũng ít được sử dụng, mà một phần lý do bởi vì Python cũng ít có tài liệu về chủ đề này. Trong bài viết này, tôi sẽ giới thiệu những hiểu biết mình đã tổng hợp được từ nhiều nguồn khác nhau, liên qua tới metaclass của Python. Có thể nó ít được sử dụng bởi nó cũng không cần thiết cho lắm, tuy nhiên, hiểu biết cặn kẽ về ngôn ngữ không bao giờ là thừa cả.</p> <blockquote> <p>Những code trong bài viết này đề sử dụng Python 3, nên có thể nó sẽ không hoạt động đúng với Python 2.</p> </blockquote> <h1 id=khai-niem-co-ban>Khái niệm cơ bản<a class=headerlink href=#khai-niem-co-ban title="Permanent link">&para;</a></h1> <p>Chúng ta sẽ dần dần tìm hiểu từng khái niệm, từ cơ bản đến nâng cao để có thể hiểu được metaclass của Python.</p> <h2 id=class-cung-la-oi-tuong>Class cũng là đối tượng<a class=headerlink href=#class-cung-la-oi-tuong title="Permanent link">&para;</a></h2> <p>Trước khi hiểu được metaclass, chúng ta cần hiểu được class của Python trước. Python có những ý tưởng rất bá đạo về việc xây dựng class, lấy cảm hứng từ ngôn ngữ <a href=https://en.wikipedia.org/wiki/Smalltalk>Smalltalk</a>.</p> <p>Trong phần lớn ngôn ngữ lập trình, class là phần code miêu tả cách tạo ra các đối tượng. Python cũng tương tự như vậy.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>bar</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>bar</span><span class=p>)</span>
<span class=go>&lt;__main__.Foo object at 0x7f9eba142ba8&gt;</span>
</pre></div> <p>Nhưng không chỉ có vậy, trong Python, <strong>class cũng là đối tượng</strong>. Ngay khi bạn sử dụng từ khóa <code>class</code>, Python sẽ thực thi nó là tạo ra một đối tượng.</p> <p>Ví dụ, khi bạn khai báo class</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
</pre></div> <p>Thì trong bộ nhớ, một đối tượng tên là <code>Foo</code> sẽ được tạo ra. Tuy nhiên, đây là một đối tượng đặc biệt, đối tượng dùng để tạo ra các đối tượng khác (instance của class). Tuy nhiên, vì là một đối tượng, nên bạn có thể:</p> <ul> <li>gán chúng cho các biến</li> <li>copy nó</li> <li>thêm thuộc tính cho nó</li> <li>dùng nó làm tham số cho các hàm</li> </ul> <p>Ví dụ:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span> <span class=c1># bạn có thể print vì class cũng là đối tượng</span>
<span class=go>&lt;class &#39;__main__.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>echo</span><span class=p>(</span><span class=n>o</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>print</span><span class=p>(</span><span class=n>o</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>echo</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span> <span class=c1># bạn có thể truyền class làm tham số cho hàm</span>
<span class=go>&lt;class &#39;__main__.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=nb>hasattr</span><span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=s1>&#39;attribute&#39;</span><span class=p>))</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>Foo</span><span class=o>.</span><span class=n>attribute</span> <span class=o>=</span> <span class=s1>&#39;foo&#39;</span> <span class=c1># bạn có thể thêm thuộc tính cho class</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=nb>hasattr</span><span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=s1>&#39;attribute&#39;</span><span class=p>))</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=go>foo</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>FooCopy</span> <span class=o>=</span> <span class=n>Foo</span> <span class=c1># bạn có thể gán class cho biến</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>FooCopy</span><span class=o>.</span><span class=n>attribute</span><span class=p>)</span>
<span class=go>foo</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>FooCopy</span><span class=p>())</span>
<span class=go>&lt;__main__.Foo object at 0x7f9eba142da0&gt;</span>
</pre></div> <h2 id=tao-ra-cac-class-ong>Tạo ra các class động<a class=headerlink href=#tao-ra-cac-class-ong title="Permanent link">&para;</a></h2> <p>Bởi vì class cũng là đối tượng, nên chúng ta có thể tạo ra các class động, giống như tất cả các đối tượng khác.</p> <p>Trước hết, bạn có thể tạo ra class trong một hàm như sau:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>choose_class</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>if</span> <span class=n>name</span> <span class=o>==</span> <span class=s1>&#39;foo&#39;</span><span class=p>:</span>
<span class=gp>... </span>        <span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>            <span class=k>pass</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>Foo</span> <span class=c1># return class chứ không phải instance</span>
<span class=gp>... </span>    <span class=k>else</span><span class=p>:</span>
<span class=gp>... </span>        <span class=k>class</span> <span class=nc>Bar</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>            <span class=k>pass</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>Bar</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>MyClass</span> <span class=o>=</span> <span class=n>choose_class</span><span class=p>(</span><span class=s1>&#39;foo&#39;</span><span class=p>)</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>MyClass</span><span class=p>)</span> <span class=c1># in ra class</span>
<span class=go>&lt;class &#39;__main__.choose_class.&lt;locals&gt;.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>MyClass</span><span class=p>())</span> <span class=c1># tạo ra một instance của class</span>
<span class=go>&lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x7f9eba142eb8&gt;</span>
</pre></div> <p>Tuy nhiên, như vậy cũng chưa phải là động lắm, bởi vì bạn vẫn cần phải code toàn bộ nội dung của class. Bởi vì class cũng là đối tượng, nó nhất định được tạo ra bởi một thứ gì khác.</p> <p>Khi bạn dùng từ khóa <code>class</code>, Python tự động tạo đối tượng đó cho bạn. Tuy nhiên, bạn vẫn có thể làm việc này bằng tay.</p> <p>Python có hàm <code>type</code>, cho chúng ta biết loại của đối tượng được truyền vào.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>&lt;class &#39;int&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=s2>&quot;1&quot;</span><span class=p>)</span>
<span class=go>&lt;class &#39;str&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=n>Foo</span><span class=p>())</span>
<span class=go>&lt;class &#39;__main__.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span>
<span class=go>&lt;class &#39;type&#39;&gt;</span>
</pre></div> <p>Như vậy, hàm type có thể cho chúng ta biến class của đối tượng được truyền vào. Nó cũng tương tự như hàm <code>isinstance</code> vậy. Và bạn có để ý kết quả của ví dụ cuối cùng ở trên không? Class <code>Foo</code> là instance của class <code>type</code>.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>bar</span><span class=p>,</span> <span class=n>Foo</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>isinstance</span><span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=nb>type</span><span class=p>)</span>
<span class=go>True</span>
</pre></div> <p>Vậy là class cũng là đối tượng, và đối tượng này được tạo bởi một thứ khác. Chúng ta gọi những thứ tạo ra class đó là là metaclass. Và như ví dụ trên, <code>type</code> là một metaclass như thế. Chúng ta có thể khái quát mối quan hệ đó bằng sơ đồ dưới đây.</p> <p><img alt=relations src=https://i.imgur.com/hbNFgPW.png></p> <p>Mọi thứ trong Python, bất kể số, xâu, hàm, phương thức, v.v đều là đối tượng trong Python. Tất cả chúng đều là đối tượng, nên chúng phải được tạo ra bởi một class. Và chúng đều có thuộc tính <code>__class__</code> để chúng ta kiểm tra việc này.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>age</span> <span class=o>=</span> <span class=mi>25</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>age</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;int&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span> <span class=o>=</span> <span class=s2>&quot;AnhTN&quot;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;str&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>foo</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;function&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Bar</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>bar</span> <span class=o>=</span> <span class=n>Bar</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>bar</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;__main__.Bar&#39;&gt;</span>
</pre></div> <p>Bây giờ, chúng ta sẽ kiểm tra <code>__class__</code> của mọi class?</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>age</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;type&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>name</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;type&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;type&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>bar</span><span class=o>.</span><span class=vm>__class__</span><span class=o>.</span><span class=vm>__class__</span>
<span class=go>&lt;class &#39;type&#39;&gt;</span>
</pre></div> <p>Vậy, <code>type</code> là một metaclass có sẵn của Python. Và mặc định, các class trong Python đều được tạo ra bởi <code>type</code>. Tất nhiên là bạn có thể tạo ra metaclass của riêng mình nếu muốn. Chúng ta sẽ dần dần tìm hiểu trong những phần tiếp theo.</p> <p>Bây giờ, chúng ta sẽ tìm hiểu kỹ hơn về quá trình tạo ra một class.</p> <h2 id=su-dung-metaclass-co-ban>Sử dụng metaclass cơ bản<a class=headerlink href=#su-dung-metaclass-co-ban title="Permanent link">&para;</a></h2> <p>Ở ví dụ trước, chúng ta đã thấy, <code>type</code> là một hàm cho chúng ta biết class được dùng để tạo ra đối tượng. Và sau đó, chúng ta lại thấy, <code>type</code> còn có khá năng khác nữa. Nó là một metaclass được dùng để tạo ra các class.</p> <blockquote> <p>Một hàm và một metaclass có cùng tên nên nhiều khi nó gây hiểu nhầm. Đây là vấn đề liên quan đến tương thích ngược của Python nên vấn đề sẽ còn tồn tại, không biết đến bao giờ.</p> </blockquote> <p><code>type</code> (metaclass) sẽ nhận đầu vào là những mô tả của class và trả kết quả là một class.</p> <div class=codehilite><pre><span></span><span class=nb>type</span><span class=p>(</span><span class=o>&lt;</span><span class=n>name</span> <span class=n>of</span> <span class=n>the</span> <span class=n>class</span><span class=o>&gt;</span><span class=p>,</span>
     <span class=o>&lt;</span><span class=nb>tuple</span> <span class=n>of</span> <span class=n>the</span> <span class=n>parent</span> <span class=k>class</span> <span class=err>(</span><span class=nc>for</span> <span class=n>inheritance</span><span class=p>,</span> <span class=n>can</span> <span class=n>be</span> <span class=n>empty</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span>
     <span class=o>&lt;</span><span class=n>dictionary</span> <span class=n>containing</span> <span class=n>attributes</span> <span class=n>names</span> <span class=ow>and</span> <span class=n>values</span><span class=p>)</span><span class=o>&gt;</span>
</pre></div> <p>Ví dụ:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
</pre></div> <p>Có thể thực hiện bằng tay như sau:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>Foo</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=s1>&#39;Foo&#39;</span><span class=p>,</span> <span class=p>(),</span> <span class=p>{})</span> <span class=c1># kết quả trả về là một class</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span>
<span class=go>&lt;class &#39;__main__.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=p>())</span> <span class=c1># tạo một instance của class `Foo`</span>
<span class=go>&lt;__main__.Foo object at 0x7f9eba142f98&gt;</span>
</pre></div> <p>Trong ví dụ trên, chúng ta sử dụng tên <code>Foo</code> làm tên của class và cũng là biến nhận kết quả trả về của <code>type</code>. Kết quả trả về này chính là một class tên <code>Foo</code>. Tất nhiên là chúng ta có thể dùng một biến với tên khác, nhưng như vậy sẽ khó hiểu hơn kha khá.</p> <p><code>type</code> chấp nhận một dictionary định nghĩa các thuộc tính của class đó. Nên:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=gp>... </span>    <span class=n>bar</span> <span class=o>=</span> <span class=bp>True</span>
<span class=gp>...</span>
</pre></div> <p>Có thể thực hiện bằng</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>Foo</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=s1>&#39;Foo&#39;</span><span class=p>,</span> <span class=p>(),</span> <span class=p>{</span><span class=s1>&#39;bar&#39;</span><span class=p>:</span> <span class=bp>True</span><span class=p>})</span>
</pre></div> <p>Và chúng ta có thể sử dụng <code>Foo</code> như những class bình thường khác.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span>
<span class=go>&lt;class &#39;__main__.Foo&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=o>.</span><span class=n>bar</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>foo</span><span class=p>)</span>
<span class=go>&lt;__main__.Foo object at 0x7f9eba142f98&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>foo</span><span class=o>.</span><span class=n>bar</span><span class=p>)</span>
<span class=go>True</span>
</pre></div> <p>Chúng ta cũng có thể sử dụng cách này với các class kế thừa nhau. Ví dụ:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooChild</span><span class=p>(</span><span class=n>Foo</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
</pre></div> <p>có thể thực hiện bằng:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>FooChild</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=s1>&#39;FooChild&#39;</span><span class=p>,</span> <span class=p>(</span><span class=n>Foo</span><span class=p>,),</span> <span class=p>{})</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>FooChild</span><span class=p>)</span>
<span class=go>&lt;class &#39;__main__.FooChild&#39;&gt;</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>FooChild</span><span class=o>.</span><span class=n>bar</span><span class=p>)</span> <span class=c1># thuộc tính `bar` kế thừa từ `Foo`</span>
<span class=go>True</span>
</pre></div> <p>Nếu bạn muốn thêm phương thức cho class của bạn. Rất đơn giản, hãy định nghĩa một hàm với tham số phù hợp (<code>self</code>) và gán nó như là thuộc tính của class.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>echo_bar</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>print</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>bar</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>FooChild</span> <span class=o>=</span> <span class=nb>type</span><span class=p>(</span><span class=s1>&#39;FooChild&#39;</span><span class=p>,</span> <span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=p>),</span> <span class=p>{</span><span class=s1>&#39;echo_bar&#39;</span><span class=p>:</span> <span class=n>echo_bar</span><span class=p>})</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>Foo</span><span class=p>,</span> <span class=s1>&#39;echo_bar&#39;</span><span class=p>)</span>
<span class=go>False</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>FooChild</span><span class=p>,</span> <span class=s1>&#39;echo_bar&#39;</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo_child</span> <span class=o>=</span> <span class=n>FooChild</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo_child</span><span class=o>.</span><span class=n>echo_bar</span><span class=p>()</span>
<span class=go>True</span>
</pre></div> <p>Bạn cũng có thể thêm các thuộc tính kể cả khi class đã được định nghĩa rồi, giống như thêm phương thức cho các class thông thường khác.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>def</span> <span class=nf>more_method</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>print</span><span class=p>(</span><span class=s2>&quot;Another method&quot;</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>FooChild</span><span class=o>.</span><span class=n>more_method</span> <span class=o>=</span> <span class=n>more_method</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>hasattr</span><span class=p>(</span><span class=n>FooChild</span><span class=p>,</span> <span class=s1>&#39;more_method&#39;</span><span class=p>)</span>
<span class=go>True</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foo_child</span><span class=o>.</span><span class=n>more_method</span><span class=p>()</span>
<span class=go>Another method</span>
</pre></div> <p>Bài học rút ra là gì? Đó là class của Python cũng là đối tượng, và chúng ta có thể tạo ra chúng động, tạo ra khi cần và thêm thuộc tính nếu muốn.</p> <p>Và class là một đối tượng đặc biệt, nó được tạo ra bởi metaclass. Bản thân lệnh <code>class</code> cũng chứa nhiều bí ẩn phía sau. Đó là thiết lập các thuộc tính <code>__qualname__</code>, <code>__doc__</code>, cũng như gọi phương thức <code>__prepare__</code>. Chúng ta sẽ tìm hiểu về chúng ở phần sau.</p> <h2 id=tong-ket-the-nao-la-metaclass>Tổng kết: Thế nào là metaclass<a class=headerlink href=#tong-ket-the-nao-la-metaclass title="Permanent link">&para;</a></h2> <p>Class là công cụ để tạo ra các đối tượng. Bạn định nghĩa class và sau đó dùng class để tạo ra các đối tượng.</p> <p>Và bây giờ, chúng ta biết rằng, class của Python cũng là đối tượng (đặc biệt). Và metaclass là công cụ để tạo ra những đối tượng đặc biệt này. Metaclass có thể gọi là class của class.</p> <p>Và chúng ta cũng học cách sử dụng <code>type</code> để tạo ra các class. Đó là bởi vì <code>type</code> cũng là metaclass. Và thực sự <code>type</code> là metaclass của mọi class trong Python.</p> <p>Có khi nào bạn thắc mắc, tại sao class của class (<code>type</code>) lại chỉ viết thường không? Tại sao không phải là <code>Type</code>?</p> <p>Thực ra tôi cũng không biết, nhưng chắc nó cũng tương tự như trường hợp của các class <code>int</code> (số nguyên), <code>str</code> (xâu ký tự). <code>type</code> cũng là một class để tạo ra các class khác.</p> <h1 id=kien-thuc-nang-cao>Kiến thức nâng cao<a class=headerlink href=#kien-thuc-nang-cao title="Permanent link">&para;</a></h1> <h2 id=qua-trinh-tao-instance>Quá trình tạo instance<a class=headerlink href=#qua-trinh-tao-instance title="Permanent link">&para;</a></h2> <p>Sơ đồ dưới đây minh hoạt quá trình tạo ra một instance:</p> <p><img alt="instance creation workflow" src=https://i.imgur.com/TGx1s0r.png></p> <p>Sơ đồ trên có thể hiểu như sau:</p> <ul> <li>Khi tạo một instance <code>Metaclass.__call__</code> sẽ gọi <code>Class.__new__</code>.</li> <li><code>Class.__new__</code> sẽ trả về một instance của <code>Class</code>.</li> <li><code>Metaclass.__call__</code> sẽ trả về bất cứ thứ gì mà <code>Class.__new__</code> trả về. Nếu một instance của <code>Class</code> được trả về thì nó sẽ gọi <code>Class.__init__</code>.</li> </ul> <h2 id=qua-trinh-tao-class>Quá trình tạo class<a class=headerlink href=#qua-trinh-tao-class title="Permanent link">&para;</a></h2> <p>Việc tạo ra class, thực ra là tạo một instance của metaclass, nên cũng tương tự như vậy:</p> <p><img alt="class creation workflow" src=https://i.imgur.com/LIe9mTX.png></p> <p>Một số lưu ý:</p> <ul> <li><code>Metaclass.__prepare__</code> trả về một đối tượng làm namespace.</li> <li><code>Metaclass.__new__</code> trả về đối tượng <code>Class</code>.</li> <li><code>MetaMetaclass.__call__</code> trả về bất cứ thứ gì <code>Metaclass.__new__</code> trả về. Nếu nó trả về một instance của <code>Metaclass</code> thì nó cũng gọi phương thức <code>Metaclass.__init__</code>.</li> </ul> <p>Các phương thức <code>__prepare__</code>, <code>__new__</code>, <code>__init__</code> được gọi là magic method. Và chúng ta sẽ tìm hiểu về chúng kỹ hơn ở phần sau.</p> <p>Như vậy, metaclass cho phép chúng ta thay đổi hầu hết các bước trong vòng đời của một đối tượng.</p> <h2 id=metaclass-la-callable>Metaclass là callable<a class=headerlink href=#metaclass-la-callable title="Permanent link">&para;</a></h2> <p>Nhìn vào sơ đồ trên, bạn sẽ để ý rằng, việc tạo ra một instance phải đi qua <code>Metaclass.__call__</code>. Điều đó có nghĩa là bạn có thể dùng bất cứ callable nào làm metaclass.</p> <blockquote> <p>Callable là bất cứ thứ gì có thể gọi và thực thi được. Một đối tượng là callable nếu:</p> <ul> <li>là một instance của class có phương thức <code>__call__</code></li> <li>một loại dữ liệu có thuộc tính <code>tp_call</code> (struct của C)</li> </ul> <p>Phương thức <code>__call__</code> được gọi khi instance được gọi như một hàm.</p> </blockquote> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Foo</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=k>print</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=go>..</span>
<span class=go>Foo () {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__qualname__&#39;: &#39;Foo&#39;}</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>print</span><span class=p>(</span><span class=n>Foo</span><span class=p>)</span>
<span class=go>None</span>
</pre></div> <p>Nếu bạn sử dụng <strong>hàm</strong> làm metaclass, thì các class sẽ không kế thừa thừ metaclass của hàm đó, mà nó sử dụng bất cứ thứ gì mà hàm đó trả về.</p> <h2 id=class-con-ke-thua-metaclass>Class con kế thừa metaclass<a class=headerlink href=#class-con-ke-thua-metaclass title="Permanent link">&para;</a></h2> <p>Một lợi ích so sánh với các class decorator là class con kế thừa metaclass.</p> <p>Đây là kết quả của việc <code>Metaclass.__call__</code> trả kết quả là một đối tượng có <code>__class__</code> là <code>Metaclass</code>.</p> <h2 id=han-che-dung-nhieu-metaclass>Hạn chế dùng nhiều metaclass<a class=headerlink href=#han-che-dung-nhieu-metaclass title="Permanent link">&para;</a></h2> <p>Python cho phép bạn định nghĩa một class kế thừa từ nhiều class khác nhau. Python cũng cho phép chúng ta định nghĩa nhiều metaclass khác nhau. Tuy nhiên, có một yêu cầu bắt buộc, đó là mọi thứ phải tuyến tính - cây kế thừa chỉ có 1 lá duy nhất.</p> <p>Trong ví dụ dưới đây, việc kế thừa không được phép vì đang tồn tại hai lá (<code>Meta1</code> và <code>Meta2</code>)</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Meta1</span><span class=p>(</span><span class=nb>type</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Meta2</span><span class=p>(</span><span class=nb>type</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Base1</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>Meta1</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Base2</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>Meta2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>(</span><span class=n>Base1</span><span class=p>,</span> <span class=n>Base2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gt>Traceback (most recent call last):</span>
  File <span class=nb>&quot;&lt;stdin&gt;&quot;</span>, line <span class=m>1</span>, in <span class=n>&lt;module&gt;</span>
<span class=gr>TypeError</span>: <span class=n>metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases</span>
</pre></div> <p>Nhưng ví dụ dưới đây lại hoạt động bình thường (metaclass là lá trong cây kế thừa)</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Meta</span><span class=p>(</span><span class=nb>type</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>SubMeta</span><span class=p>(</span><span class=n>Meta</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Base1</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>Meta</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Base2</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>SubMeta</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>(</span><span class=n>Base1</span><span class=p>,</span> <span class=n>Base2</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>type</span><span class=p>(</span><span class=n>FooBar</span><span class=p>)</span>
<span class=go>&lt;class &#39;__main__.SubMeta&#39;&gt;</span>
</pre></div> <h1 id=magic-method>Magic method<a class=headerlink href=#magic-method title="Permanent link">&para;</a></h1> <p>Một tính năng rất đặc trưng của Python mà <strong>magic method</strong>: nó cho phép lập trình viên có thể thay đổi hoạt động của các phép toán và cả các đối tượng. Bạn có thể làm nó như ví dụ dưới đây:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>:</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__call__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s2>&quot;Class works like a function&quot;</span><span class=p>)</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>f</span> <span class=o>=</span> <span class=n>FooBar</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>f</span><span class=p>()</span>
<span class=go>Class works like a function</span>
</pre></div> <p>Metaclass hoạt động dựa vào rất nhiều magic method khác nhau, nên việc tìm hiểu chúng khá cần thiết.</p> <h2 id=slot>Slot<a class=headerlink href=#slot title="Permanent link">&para;</a></h2> <p>Khi bạn định nghĩa một magic method trong class của bạn, hàm đó sẽ hoạt động giống như một pointer trong <a href=https://docs.python.org/3/c-api/typeobj.html><code>struct</code> dùng để mô tả class</a>. Hơn nữa, nó còn là một phần trong <code>__dict__</code>. Struct đó có các trường cho mỗi magic method, vì nhiều lý do mà các trường này được gọi là <strong>type slot</strong>, mỗi magic method sẽ có một type slot tương ứng.</p> <p>Và chúng ta biết thêm một tính năng nữa. Đó là cài đặt thuộc tính thông qua thuộc tính <code>__slots__</code>. Ví dụ như sau:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>:</span>
<span class=gp>... </span>    <span class=vm>__slots__</span> <span class=o>=</span> <span class=s2>&quot;foo&quot;</span><span class=p>,</span> <span class=s2>&quot;bar&quot;</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foobar</span> <span class=o>=</span> <span class=n>FooBar</span><span class=p>()</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foobar</span><span class=o>.</span><span class=n>foo</span> <span class=o>=</span> <span class=mi>1</span>
<span class=gp>&gt;&gt;&gt; </span><span class=n>foobar</span><span class=o>.</span><span class=n>bar</span> <span class=o>=</span> <span class=mi>2</span>
</pre></div> <p>Một class có thuộc tính <code>__slots__</code> sẽ tạo ra các instance không có thuộc tính <code>__dict__</code> (và do đó, sẽ dùng ít bộ nhớ hơn).</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foobar</span><span class=o>.</span><span class=vm>__dict__</span>
<span class=gt>Traceback (most recent call last):</span>
  File <span class=nb>&quot;&lt;stdin&gt;&quot;</span>, line <span class=m>1</span>, in <span class=n>&lt;module&gt;</span>
<span class=gr>AttributeError</span>: <span class=n>&#39;FooBar&#39; object has no attribute &#39;__dict__&#39;</span>
</pre></div> <p>Một hệ quả của việc này là instance của chúng ta không thể thêm bất cứ thuộc tính nào ngoài những thuộc tính đã được định nghĩa từ trước. Nếu cố cho thêm thuộc tính mới, bạn sẽ nhận được <code>AttributeError</code>:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>foobar</span><span class=o>.</span><span class=n>more_attr</span> <span class=o>=</span> <span class=mi>3</span>
<span class=gt>Traceback (most recent call last):</span>
  File <span class=nb>&quot;&lt;stdin&gt;&quot;</span>, line <span class=m>1</span>, in <span class=n>&lt;module&gt;</span>
<span class=gr>AttributeError</span>: <span class=n>&#39;FooBar&#39; object has no attribute &#39;more_attr&#39;</span>
</pre></div> <h2 id=tham-chieu-thuoc-tinh-cua-oi-tuong>Tham chiếu thuộc tính của đối tượng<a class=headerlink href=#tham-chieu-thuoc-tinh-cua-oi-tuong title="Permanent link">&para;</a></h2> <p>Những điều dưới đây có thể gây nhầm lần bởi nó hơi khác một chút so với Python 2.</p> <p>Giả sử <code>Class</code> là một class có instance là <code>instance</code>. Nếu chúng ta cần gọi đến thuộc tính <code>instance.foobar</code>, quá trình sẽ diễn ra như sau:</p> <ul> <li>Mặc định sẽ là gọi type slot cho <code>Class.__getattribute__ (tp_getattro)</code>.</li> <li><code>foobar</code> có phải là một data descriptor trong <code>Class.__dict__</code> hay không?<ul> <li>Nếu có, trả về kết quả của <code>Class.__dict__['foobar'].__get__(instance, Class)</code>.</li> </ul> </li> <li><code>foobar</code> có phải là một phần tử của <code>instance.__dict__</code> hay không?<ul> <li>Nếu có, trả về kết quả <code>instance.__dict__['foobar']</code>.</li> </ul> </li> <li><code>foobar</code> là một phần tử trong <code>Class.__dict__</code> nhưng không phải là data descriptor?<ul> <li>Nếu đúng, trả về kết quả của <code>Class.__dict__['foobar'].__get__(instance, klass)</code>.</li> </ul> </li> <li>Nếu thuộc tính vẫn không được tìm thấy, nếu có tồn tại <code>Class.__getattr__</code> thì gọi <code>Class.__getattr__('foobar')</code>.</li> </ul> <blockquote> <p>Data descriptor là một đối tượng có cả phương thức <code>__get__</code> và phương thức <code>__set__</code>. <a href=https://docs.python.org/3/reference/datamodel.html#invoking-descriptors>Tham khảo</a>.</p> </blockquote> <p>Sơ đồ sau sẽ minh họa cho quá trình này.</p> <p><img alt="objects attribute lookup" src=https://i.imgur.com/e2bZfqf.png></p> <blockquote> <p>Trong sơ đồ trên, dấu <code>:</code> được dùng thay cho dấu <code>.</code> để tránh những hiểu nhầm đáng tiếc.</p> </blockquote> <h2 id=tham-chieu-thuoc-tinh-cua-class>Tham chiếu thuộc tính của class<a class=headerlink href=#tham-chieu-thuoc-tinh-cua-class title="Permanent link">&para;</a></h2> <p>Bởi vì class còn phải hỗ trợ các phương thức <code>classmethod</code> và <code>staticmethod</code> nên quá trình tham chiếu có phức tạp hơn một chút. Nếu bạn gọi phương thức <code>Class.foobar</code> quá trình này tương đối khác với việc tham chiếu <code>instance.foobar</code>.</p> <p>Giả sử <code>Class</code> có metaclass là <code>Metaclass</code>, quá trình tham chiếu <code>Class.foobar</code> sẽ diễn ra như sau:</p> <ul> <li>Mặc định là sẽ gọi type slot cho <code>Metaclass.__getattribute__ (tp_getattro)</code>.</li> <li><code>foobar</code> là data descriptor trong <code>Metaclass.__dict__</code>?<ul> <li>Nếu đúng, trả về kết quả của <code>Metaclass.__dict__['foobar'].__get__(Class, Metaclass)</code>.</li> </ul> </li> <li><code>foobar</code> tồn tại bên trong <code>Class.__dict__</code> và có thể là bất kỳ descriptor nào?<ul> <li>Nếu đúng, trả về kết quả của <code>Class.__dict__['foobar'].__get__(None, Class)</code>.</li> </ul> </li> <li><code>Class.__dict__</code> có chứa <code>foobar</code>?<ul> <li>Nếu đúng, trả về <code>Class.__dict__['foobar']</code>.</li> </ul> </li> <li><code>foobar</code> tồn tại trong <code>Metaclass.__dict__</code> nhưng không phải descriptor?<ul> <li>Nếu đúng, trả về kết quả <code>Metaclass.__dict__['foobar'].__get__(Class, Metaclass)</code>.</li> </ul> </li> <li><code>Metaclass.__dict__</code> có chứa <code>foobar</code>?<ul> <li>Nếu đúng, trả về <code>Metaclass.__dict__['foobar']</code>.</li> </ul> </li> <li>Nếu thuộc tính vẫn không tìm thấy, nếu tồn tại <code>Metaclass.__getattr__</code>, thì gọi <code>Metaclass.__getattr__('foobar')</code>.</li> </ul> <p>Toàn bộ quá trình được minh họa bằng sơ đồ dưới đây.</p> <p><img alt="classes attribute lookup" src=https://i.imgur.com/qRyONTI.png></p> <blockquote> <p>Cũng tương tự như trên, sơ đồ này sử dụng <code>:</code> thay cho <code>.</code></p> </blockquote> <h2 id=tham-chieu-magic-method>Tham chiếu magic method<a class=headerlink href=#tham-chieu-magic-method title="Permanent link">&para;</a></h2> <p>Với magic method, việc tham chiếu được thực hiện này trong class, trực tiếp trong struct với type slot.</p> <ul> <li>Class của đối tượng có slot cho magic method hay không (được gọi <code>object-&gt;ob_type-&gt;tp_&lt;magicmethod&gt;</code> trong code C)? Nếu đúng, sử dụng type slot đó, nếu không, thao tác này không được hỗ trợ.</li> </ul> <blockquote> <p>Theo diễn giải thông thường của ngôn ngữ C:</p> <ul> <li><code>object-&gt;ob_type</code> là class của đối tượng.</li> <li><code>ob_type-&gt;tp_&lt;magicmethod&gt;</code> là type slot.</li> </ul> </blockquote> <p>Việc tham chiếu có vẻ đơn giản hơn, tuy nhiên type slot được bao bọc bởi hàm của bạn, nên các data descriptor hoạt động tốt.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>:</span>
<span class=gp>... </span>    <span class=nd>@property</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__repr__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>def</span> <span class=nf>inner</span><span class=p>():</span>
<span class=gp>... </span>            <span class=k>return</span> <span class=s2>&quot;FooBar&quot;</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=n>inner</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>repr</span><span class=p>(</span><span class=n>FooBar</span><span class=p>())</span>
<span class=go>&#39;FooBar&#39;</span>
</pre></div> <p>Quá trình tham chiếu ở trên, tôi nói là <strong>mặc định</strong>. Vậy có cách nào thay đổi được quá trình tham chiếu mặc định này hay không? Câu trả lời là có và chúng ta sẽ tìm hiểu trong phần tiếp sau đây.</p> <h2 id=phuong-thuc-__new__>Phương thức <code>__new__</code><a class=headerlink href=#phuong-thuc-__new__ title="Permanent link">&para;</a></h2> <p>Một điểm dễ gây nhầm lần giữa class và metaclass chính là phương thức <code>__new__</code>. Nó có một số quy ước rất đặc biệt.</p> <p>Phương thức <code>__new__</code> là <strong>constructor</strong> (tạo đối tượng, kết quả trả về của nó là đối tượng mới), trong khi phương thức <code>__init__</code> là <strong>initializer</strong> (khởi tạo giá trị ban đầu cho đối tượng, khi phương thức <code>__init__</code> được gọi, đối tượng đã tồn tại rồi).</p> <p>Giả sử chúng ta có class như dưới dây.</p> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>Foobar</span><span class=p>:</span>
    <span class=k>def</span> <span class=nf>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>):</span>
        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
</pre></div> <p>Nếu bạn xem lại những phần trước, có thể bạn sẽ cho rằng <code>__new__</code> sẽ được tham chiếu ở metaclass. Nhưng không, nó được tham chiếu theo phương pháp <strong>tĩnh</strong>.</p> <p>Khi class <code>FooBar</code> cần gọi magic phương thức <code>__new__</code>, nó sẽ được tham chiếu trong chính đối tượng (class) đó, chứ không tham chiếu đến các class ở tầng cao hơn. Điều này rất quan trọng, bởi cả class mà metaclass có thể định nghĩa phương thức này.</p> <ul> <li><code>FooBar.__new__</code> được dùng để tạo ra các instance của <code>FooBar</code>.</li> <li><code>type.__new__</code> được dùng để tạo ra class <code>FooBar</code> (một instance của <code>type</code>)</li> </ul> <h2 id=phuong-thuc-__prepare__>Phương thức <code>__prepare__</code><a class=headerlink href=#phuong-thuc-__prepare__ title="Permanent link">&para;</a></h2> <p>Đây là phương thức của metaclass, nó sẽ được gọi trước khi code của class được thực thi, và phương thức bắt buộc phải trả về kết quả là một dict (hoặc tương tự một dict), kết quả này sau này sẽ được dùng làm namespace cho tất cả code của class. Phương thức này mới được thêm vào từ Python 3.0, bạn có thể tham khảo thêm ở <a href=https://www.python.org/dev/peps/pep-3115/ >PEP-3115</a>.</p> <p>Nếu phương thức <code>__prepare__</code> trả về một đối tượng <code>x</code> và chúng ta có một class:</p> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>Class</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>Meta</span><span class=p>):</span>
    <span class=n>a</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=n>b</span> <span class=o>=</span> <span class=mi>2</span>
    <span class=n>c</span> <span class=o>=</span> <span class=mi>3</span>
</pre></div> <p>Thì <code>x</code> sẽ được thay đổi như sau:</p> <div class=codehilite><pre><span></span><span class=n>x</span><span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>x</span><span class=p>[</span><span class=s1>&#39;b&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span>
<span class=n>x</span><span class=p>[</span><span class=s1>&#39;c&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span>
</pre></div> <p>Đối tượng <code>x</code> này cần phải là một dict. Lưu ý rằng, <code>x</code> sẽ là được dùng làm một tham số của <code>Metaclass.__new__</code> và nếu như nó không phải một instance của dict thì bạn nên convert nó trước khi gọi <code>super().__new__</code>.</p> <p>Một điều thú vị là phương thức không tham chiếu đến phương thức <code>__new__</code>. Nó xuất hiện không hề có type slot và nó được tham chiếu thông qua tham chiếu thuộc tính của class.</p> <h2 id=chu-ky-cua-phuong-thuc>Chữ ký của phương thức<a class=headerlink href=#chu-ky-cua-phuong-thuc title="Permanent link">&para;</a></h2> <blockquote> <p>Trong lập trình, nhất là lập trình hướng đối tượng, các phương thức được định danh bằng chữ ký của phương thức. Chữ ký này là duy nhất cho mỗi phương thức và thường bao gồm tên, số lượng, kiểu dữ liệu và thứ tự của các tham số.</p> </blockquote> <p>Có nhiều điều quan trọng mà chúng ta chưa nhắc tới. Chữ ký của phương thức là một trong số chúng. Hãy xem xét các class mà metaclass với những công cụ được cài đặt sẵn.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Meta</span><span class=p>(</span><span class=nb>type</span><span class=p>):</span>
<span class=gp>... </span>    <span class=nd>@classmethod</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=nf>__prepare__</span><span class=p>(</span><span class=n>mcs</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Meta.__prepare__(mcs=</span><span class=si>%s</span><span class=s1>, name=</span><span class=si>%r</span><span class=s1>, bases=</span><span class=si>%s</span><span class=s1>, **</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=n>mcs</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=n>kwargs</span><span class=p>))</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=p>{}</span>
</pre></div> <p>Như giải thích ở trên, phương thức <code>__prepare__</code> có thể trả kết quả không phải là một instance của <code>dict</code>, vì vậy bạn cần cài đặt phương thức <code>__new__</code> để xử lý.</p> <div class=codehilite><pre><span></span><span class=gp>... </span>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=n>mcs</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=n>attrs</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Meta.__new__(mcs=</span><span class=si>%s</span><span class=s1>, name=</span><span class=si>%r</span><span class=s1>, bases=</span><span class=si>%s</span><span class=s1>, attrs=[</span><span class=si>%s</span><span class=s1>], **</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=n>mcs</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=s1>&#39;, &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>attrs</span><span class=p>),</span> <span class=n>kwargs</span><span class=p>))</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=n>mcs</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=n>attrs</span><span class=p>)</span>
</pre></div> <p>Thông thường, <code>__init__</code> ít khi được cài đặt trong metaclass bởi vì không cần thiết - class đã được tạo ra trong bộ nhớ khi <code>__init__</code> được gọi. Nó gần tương đương với việc có một class decorator với khác biệt là <code>__init__</code> sẽ chạy khi tạo ra class con, trong khi class decorator không được gọi cho class con.</p> <div class=codehilite><pre><span></span><span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=n>attrs</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Meta.__init__(cls=</span><span class=si>%s</span><span class=s1>, name=</span><span class=si>%r</span><span class=s1>, bases=</span><span class=si>%s</span><span class=s1>, attrs=[</span><span class=si>%s</span><span class=s1>], **</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=bp>cls</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=s1>&#39;, &#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>attrs</span><span class=p>),</span> <span class=n>kwargs</span><span class=p>))</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>bases</span><span class=p>,</span> <span class=n>attrs</span><span class=p>)</span>
</pre></div> <p>Phương thức <code>__call__</code> được gọi khi tạo instance của <code>Class</code>.</p> <div class=codehilite><pre><span></span><span class=gp>... </span>    <span class=k>def</span> <span class=fm>__call__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Meta.__call__(cls=</span><span class=si>%s</span><span class=s1>, args=</span><span class=si>%s</span><span class=s1>, kwargs=</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=bp>cls</span><span class=p>,</span> <span class=n>args</span><span class=p>,</span> <span class=n>kwargs</span><span class=p>))</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__call__</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
<span class=gp>...</span>
</pre></div> <p>Sử dụng <code>Meta</code>, đánh dấu <code>extra=1</code>:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>Class</span><span class=p>(</span><span class=n>metaclass</span><span class=o>=</span><span class=n>Meta</span><span class=p>,</span> <span class=n>extra</span><span class=o>=</span><span class=mi>1</span><span class=p>):</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>,</span> <span class=n>myarg</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Class.__new__(cls=</span><span class=si>%s</span><span class=s1>, myarg=</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=bp>cls</span><span class=p>,</span> <span class=n>myarg</span><span class=p>))</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__new__</span><span class=p>(</span><span class=bp>cls</span><span class=p>)</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>myarg</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>print</span><span class=p>(</span><span class=s1>&#39;Class.__init__(self=</span><span class=si>%s</span><span class=s1>, myarg=</span><span class=si>%s</span><span class=s1>)&#39;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=bp>self</span><span class=p>,</span> <span class=n>myarg</span><span class=p>))</span>
<span class=gp>... </span>        <span class=bp>self</span><span class=o>.</span><span class=n>myarg</span> <span class=o>=</span> <span class=n>myarg</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=fm>__init__</span><span class=p>()</span>
<span class=gp>... </span>    <span class=k>def</span> <span class=fm>__str__</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=gp>... </span>        <span class=k>return</span> <span class=s2>&quot;&lt;instance of Class; myargs=</span><span class=si>%s</span><span class=s2>&gt;&quot;</span> <span class=o>%</span> <span class=p>(</span>
<span class=gp>... </span>            <span class=nb>getattr</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=s1>&#39;myarg&#39;</span><span class=p>,</span> <span class=s1>&#39;MISSING&#39;</span><span class=p>),)</span>
<span class=gp>...</span>
<span class=go>Meta.__prepare__(mcs=&lt;class &#39;__main__.Meta&#39;&gt;, name=&#39;Class&#39;, bases=(), **{&#39;extra&#39;: 1})</span>
<span class=go>Meta.__new__(mcs=&lt;class &#39;__main__.Meta&#39;&gt;, name=&#39;Class&#39;, bases=(), attrs=[__str__, __module__, __qualname__, __new__, __init__], **{&#39;extra&#39;: 1})</span>
<span class=go>Meta.__init__(cls=&lt;class &#39;__main__.Class&#39;&gt;, name=&#39;Class&#39;, bases=(), attrs=[__str__, __module__, __qualname__, __new__, __init__], **{&#39;extra&#39;: 1})</span>
</pre></div> <p>Lưu ý <code>Meta.__call__</code> được gọi khi tạo instance của <code>Class</code>:</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=n>Class</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=go>Meta.__call__(cls=&lt;class &#39;__main__.Class&#39;&gt;, args=(1,), kwargs={})</span>
<span class=go>Class.__new__(cls=&lt;class &#39;__main__.Class&#39;&gt;, myarg=1)</span>
<span class=go>Class.__init__(self=&lt;instance of Class; myargs=MISSING&gt;, myarg=1)</span>
<span class=go>&lt;__main__.Class object at 0x7fd71e85a198&gt;</span>
</pre></div> <h2 id=tai-sao-chung-ta-nen-dung-metaclass>Tại sao chúng ta nên dùng metaclass?<a class=headerlink href=#tai-sao-chung-ta-nen-dung-metaclass title="Permanent link">&para;</a></h2> <p>Sau tất cả những kiến thứ trên, câu hỏi lớn bây giờ là: Tại sao chúng ta lại cần dùng metaclass?</p> <p>Thực ra, rất ít khi chúng ta dùng đến chúng:</p> <blockquote> <p>Metaclasses are deeper magic that 99% of users should never worry about. If you wonder whether you need them, you don't (the people who actually need them know with certainty that the need them, and don't need an explanation about why).</p> <p>– Python Guru Tim Peters –</p> </blockquote> <p>Mục đích chính của metaclass là tạo ra các API. Một ví dụ điển hình cho việc này là Django ORM.</p> <p>Bạn có thể định nghĩa model trong Django như bên dưới:</p> <div class=codehilite><pre><span></span><span class=k>class</span> <span class=nc>Person</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>name</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>30</span><span class=p>)</span>
    <span class=n>age</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>IntegerField</span><span class=p>()</span>
</pre></div> <p>Nhưng nếu bạn tạo ra một đối tượng:</p> <div class=codehilite><pre><span></span><span class=n>someone</span> <span class=o>=</span> <span class=n>Person</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;AnhTN&#39;</span><span class=p>,</span> <span class=n>age</span><span class=o>=</span><span class=s1>&#39;25&#39;</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>someone</span><span class=o>.</span><span class=n>age</span><span class=p>)</span>
</pre></div> <p>Lệnh <code>print</code> ở trên không in ra một đối tượng <code>IntegerField</code>. Nó in ra một số nguyên, là dữ liệu được lấy ra từ cơ sở dữ liệu.</p> <p>Chúng ta có thể làm việc này vì <code>models.Model</code> định nghĩa <code>__metaclass__</code> và nó một số xử lý bên trong và kết quả là <code>Person</code> có thể định nghĩa rất đơn giản trong khi thực tế nó thao tác rất phức tạp với cơ sở dữ liệu.</p> <p>Django làm mọi thứ trở nên đơn giản hơn bằng cách xây dựng các API và sử dụng metaclass. Mọi thao tác sẽ được thực hiện bởi API và trong suốt với người dùng.</p> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Class là những đối tượng để tạo ra các instance. Đến lượt nó, class cũng là instance của metaclass.</p> <div class=codehilite><pre><span></span><span class=gp>&gt;&gt;&gt; </span><span class=k>class</span> <span class=nc>FooBar</span><span class=p>():</span>
<span class=gp>... </span>    <span class=k>pass</span>
<span class=gp>...</span>
<span class=gp>&gt;&gt;&gt; </span><span class=nb>id</span><span class=p>(</span><span class=n>FooBar</span><span class=p>)</span>
<span class=go>32902216</span>
</pre></div> <p>Mọi thứ đều là đối tượng trong Python, và có thể nó là instance của một class hoặc một metaclass, ngoại trừ <code>type</code>.</p> <p><code>type</code> là metaclass của chính nó. Và nó không phải là thứ bạn có thể dễ dàng thay đổi bằng code Python. Nếu muốn làm gì, có lẽ bạn phải xem lại mã nguồn của ngôn ngữ.</p> <p>Ngoài ra, metaclass rất phức tạp, và bạn không cần thiết phải sử dụng nó. Bạn có thể thay đổi hành vi của một class bằng một trong hai cách sau, đơn giản hơn nhiều:</p> <ul> <li><a href=https://en.wikipedia.org/wiki/Monkey_patch>monkey patching</a></li> <li>class decorator</li> </ul> <p>Đây là những gì tôi đã tìm hiểu được. Nó có rất nhiều thứ và thực sự, metaclass quá phức tạp. Có thể tôi sẽ trở lại với chủ đề này trong tương lai, vì tôi cũng cảm thấy hình như còn thiếu gì đó!!</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#Python</span> <span>#metaclass</span> <span>#fundamental</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2016/Mar/08/python-class-decorator.html> Newer Post </a> </span> <span class=older-link> <a href=/2016/Feb/18/tips-for-improving-web-application.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>