<!DOCTYPE html><title>Algorithm: Dynamic programming - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Trong bài viết này, tôi sẽ giới thiệu với các bạn một thuật toán thần thánh: quy hoạch động. Nếu bạn tham gia các cuộc thi code, bạn nhất định phải biết thuật toán này. Gần một nửa các bài thi trong các cuộc thi code cần đến quy hoạch …"> <meta name=keywords content="algorithm, contest, dynamic programming, dp, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Algorithm: Dynamic programming - manhhomienbienthuy's space"> <meta name=twitter:description content="Trong bài viết này, tôi sẽ giới thiệu với các bạn một thuật toán thần thánh: quy hoạch động. Nếu bạn tham gia các cuộc thi code, bạn nhất định phải biết thuật toán này. Gần một nửa các bài thi trong các cuộc thi code cần đến quy hoạch …"> <meta name=twitter:image content=/https://i.imgur.com/QUkt5oB.jpg> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Algorithm: Dynamic programming </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on August 24, 2017 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2017/Aug/24/algorithm-dynamic-programming.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/QUkt5oB.jpg alt="Algorithm: Dynamic programming"> <p>Trong bài viết này, tôi sẽ giới thiệu với các bạn một thuật toán thần thánh: quy hoạch động. Nếu bạn tham gia các cuộc thi code, bạn nhất định phải biết thuật toán này.</p> <p>Gần một nửa các bài thi trong các cuộc thi code cần đến quy hoạch động. Tất nhiên, có những cách khác để giải bài toán đó. Nhưng vì các cuộc thi code đều có giới hạn về thời gian, cũng như bộ nhớ của chương trình, nên một thuật toán hiệu quả là cực kỳ cần thiết. Và trong những trường hợp như vậy, quy hoạch động là một trong những thuật toán xuất hiện nhiều nhất.</p> <p>Thuật toán quy hoạch động được ưa chuộng bởi vì ban đầu, bài toán có muôn hình vạn trạng và bạn phải suy nghĩ rất nhiều mới tìm ra được lời giải. Không có một công thức chuẩn mực nào áp dụng được cho mọi bài toán. Bởi vì sự phổ biến của nó, bạn bắt buộc phải cực kỳ thuần thục thuật toán này nếu muốn có kết quả tốt trong các cuộc thi.</p> <p>Cách hiệu quả nhất để tìm hiểu một thuật toán là xem xét những ví dụ cụ thể. Trong bài viết này, tôi sẽ giới thiệu vài ví dụ trong phần sau. Có thể nó chưa đầy đủ, bạn có thể đọc thêm ở các bài viết khác. Giới thiệu với các bạn một tài liệu rất hay: <a href=https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/ >Dynamic Programming: From novice to advanced</a></p> <h1 id=khi-nao-thi-dung-quy-hoach-ong>Khi nào thì dùng quy hoạch động<a class=headerlink href=#khi-nao-thi-dung-quy-hoach-ong title="Permanent link">&para;</a></h1> <p>Khi nào thì chúng ta cần đến quy hoạch động? Đó là một câu hỏi rất khó trả lời. Không có một công thức nào cho các bài toán như vậy.</p> <p>Tuy nhiên, có một số tính chất của bài toán mà bạn có thể nghĩ đến quy hoạch động. Dưới đây là hai tính chất nổi bật nhất trong số chúng:</p> <ul> <li>Bài toán có các bài toán con gối nhau</li> <li>Bài toán có cấu trúc con tối ưu</li> </ul> <p>Thường thì một bài toán có đủ cả hai tính chất này, chúng ta có thể dùng quy hoạch động được. Một câu hỏi rất thú vị là không dùng quy hoạch động có được không? Câu trả lời là có, nhưng nếu bạn đi thi code, bạn trượt là cái chắc. Để hiểu rõ hơn, chúng ta sẽ tìm hiểu từng tính chất một trong những phần dưới đây</p> <h2 id=bai-toan-con-goi-nhau>Bài toán con gối nhau<a class=headerlink href=#bai-toan-con-goi-nhau title="Permanent link">&para;</a></h2> <p>Tương tự như thuật toán chia để trị, quy hoạch động cũng chia bài toán lớn thành các bài toán con nhỏ hơn. Quy hoạch động được sử dụng khi các bài toán con này được gọi đi gọi lại. Phương pháp quy hoạch động sẽ lưu kết quả của bài toán con này, và khi được gọi, nó sẽ không cần phải tính lại, do đó làm giảm thời gian tính toán.</p> <p>Quy hoạch động sẽ không thể áp dụng được (hoặc nói đúng hơn là áp dụng cũng không có tác dụng gì) khi các bài toán con không gối nhau. Ví dụ với thuật toán tìm kiếm nhị phân, quy hoạch động cũng không thể tối ưu được gì cả, bởi vì mỗi khi chia nhỏ bài toán lớn thành các bài toán con, mỗi bài toán cũng chỉ cần giải một lần mà không bao giờ được gọi lại.</p> <p>Một ví dụ rất điển hình của bài toán con gối nhau là bài toán tính số Fibonacci. Bài toán quá nổi tiếng rồi, chúng ta có thể tính toán số Fibonacci theo đúng công thức như sau:</p> <div class=codehilite><pre><span></span><span class=k>def</span> <span class=nf>fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>return</span> <span class=n>n</span>
    <span class=k>return</span> <span class=n>fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
</pre></div> <p>Nếu tính toán như trên, chúng ta rất nhiều bài toán con sẽ được tính đi tính lại, điển hình là các số <code>fib(0)</code> và <code>fib(1)</code>.</p> <p>Và quy hoạch động chính là một trong số những phương pháp có thể giúp chúng ta tối ưu hóa quá trình tính toán này. Mỗi bài toán con (số fib) sẽ được lưu lại trước khi tính những bài toán con lớn hơn. Nhờ đó, mà việc tính toán giảm đi đáng kể, mỗi bài toán con chỉ cần tính <strong>đúng một lần</strong>.</p> <p>Một ví dụ quy hoạch động với bài toán này như sau:</p> <div class=codehilite><pre><span></span><span class=k>def</span> <span class=nf>fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
    <span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
    <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>
    <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span>
    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</pre></div> <p>Qua ví dụ trên, bạn đã thấy được sức mạnh vượt trội của quy hoạch động chưa? Đó cũng chính là lý do mà nó rất được ưa chuộng trong các cuộc thi lập trình, khi mà thời gian và bộ nhớ đều là hữu hạn (và thường khá nhỏ).</p> <h2 id=cau-truc-con-toi-uu>Cấu trúc con tối ưu<a class=headerlink href=#cau-truc-con-toi-uu title="Permanent link">&para;</a></h2> <p>Cấu trúc con tối ưu là một tính chất là lời giải của bài toán lớn sẽ là tập hợp lời giải từ các bài toán nhỏ hơn.</p> <p>Mình lấy một ví dụ cho dễ hiểu:</p> <p>Trong bài toán tìm đường đi ngắn nhất trong đồ thị, nếu một node <code>x</code> nằm trên đường đi ngắn nhất giữa hai node <code>u</code>, <code>v</code> thì đường đi ngắn nhất từ <code>u</code> đến <code>v</code> sẽ là tổng hợp của đường đi ngắn nhất từ <code>u</code> đến <code>x</code> và đường đi ngắn nhất từ <code>x</code> đến v. Môt số thuật toán tìm đường trên đồ thị (nổi tiếng nhất có lẽ là <a href=https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm>Dijkstra</a>) đều dựa trên tính chất này, và nó cũng áp dụng quy hoạch động.</p> <p>Tính chất cấu trúc con tối ưu rất quan trọng. Nó cho phép chúng ta giải bài toán lớn dựa vào các bài toán con đã giải được. Nếu không có tính chất này, chúng ta không thể áp dụng quy hoạch động được.</p> <p>Không phải bài toán nào cũng có tính chất cấu trúc con tối ưu này. Ví dụ với đồ thị sau:</p> <p><img alt="longest path" src=https://i.imgur.com/q9JRnHN.png></p> <p>Đường đi <strong>dài nhất</strong> từ <code>q -&gt; t</code> sẽ là <code>q -&gt; r -&gt; t</code> hoặc <code>q -&gt; s -&gt; t</code>. Nhưng không giống như bài toán tìm đường đi ngắn nhất, đường đi dài nhất không phải là tổ hợp của những đường đi thành phần, do đó, bài toán này không có cấu trúc con tối ưu.</p> <p>Ví dụ, đường <code>q -&gt; r -&gt; t</code> không phải là tổ hợp của đường đi dài nhất từ <code>q -&gt; r</code> và đường đi dài nhất từ <code>r -&gt; t</code>. Bởi vì, đường đi dài nhất <code>q -&gt; r</code> phải là <code>q -&gt; s -&gt; t -&gt; r</code> và đường đi dài nhất từ <code>r -&gt; t</code> phải là <code>r -&gt; q -&gt; s -&gt; t</code>.</p> <h1 id=mot-so-bai-toan-quy-hoach-ong>Một số bài toán quy hoạch động<a class=headerlink href=#mot-so-bai-toan-quy-hoach-ong title="Permanent link">&para;</a></h1> <p>Trong phần này, chúng ta sẽ làm quen với quy hoạch động thông qua một số ví dụ cụ thể. Chúng ta sẽ xem xét cách quy hoạch động được áp dụng vào các bài toán cụ thể như thế nào, đồng thời qua đó, chúng ta sẽ hiểu hơn về các tính chất ở phần trước.</p> <h2 id=vi-du-1-bai-toan-kinh-ien-voi-ong-xu>Ví dụ 1: Bài toán kinh điển với đồng xu<a class=headerlink href=#vi-du-1-bai-toan-kinh-ien-voi-ong-xu title="Permanent link">&para;</a></h2> <p>Đây là một ví dụ rất kinh điển khi học về quy hoạch động. Có thể có nhiều cách phát biểu khác nhau nhưng về cơ bản, nội dung của nó sẽ tương tự như sau.</p> <blockquote> <p>Giả sử chúng ta có <code>n</code> đồng xu nặng lần lượt là <code>W1, W2, ..., Wn</code>, và bài toán đặt ra là tìm số lượng đồng xu nhỏ nhất để tổng khối lượng của chúng là một giá trị <code>S</code>. Tất nhiên, số lượng đồng xu là không giới hạn.</p> </blockquote> <p>Với bài toán này, chúng ta cần xây dựng và giải các bài toán con gối nhau. Với ví dụ của chúng ta, mỗi bài toán con <code>dp(P)</code> với <code>P &lt;= S</code> là bài toán tìm số đồng xu nhỏ nhất để khối lượng của chúng là <code>P</code>. và <code>dp(P) = k</code> chính là số lượng đồng xu nhỏ nhất đó.</p> <p>Chúng ta sẽ áp dụng phương pháp quy hoạch động bằng cách bắt đầu từ bài toán con <code>dp(0)</code> sau đó tiếp tục với các bài toán con lớn hơn. Lời giải của các bài toán con sẽ được xây dựng lần lượt cho đến chúng ta xây dựng đến bài toán <code>dp(S)</code> và đó chính là kết quả của bài toán lớn. Một điều cần lưu ý với kỹ thuật này là bài toán con tiếp theo sẽ không thể giải được nếu chúng ta chưa giải bài toán con trước đó.</p> <p>Cuối cùng là phần khó nhất của mọi bài toán quy hoạch động, đó là trả lời câu hỏi: cấu trúc con tối ưu của bài toán này ở đâu. Hay nói một cách khác, làm thế nào để từ những bài toán nhỏ hơn có thể tổ hợp ra lời giải cho bài toán lớn. Với vị dụ kinh điển này, mọi thứ sẽ tương đối đơn giản, nhưng với những bài toán phức tạp hơn, chúng ta cần suy nghĩ và tính toán nhiều hơn.</p> <p>Quay trở lại với bài toán của chúng ta. Giả sử <code>P</code> là tổng khối lượng của các đồng xu nặng lần lượt là <code>V1, V2, ..., Vj</code>. Để có được khối lượng <code>P</code>, chúng ta cần thêm vài đúng 1 đồng xu nặng <code>U</code> vào khối lượng <code>Q</code> sao cho <code>Q + U = P</code>. Tất nhiên, bài toán con <code>dp(Q)</code> chúng ta đã có lời giải nên chúng ta sẽ biết được cần bao nhiêu đồng xu cho <code>dp(P)</code>. Và vì có nhiều đồng xu <code>U</code> (nhiều nhưng hữu hạn) nên chúng ta có thể cần đến nhiều bài toán con trước đó, và <code>dp(p)</code> là giá trị nhỏ nhất sau khi tổng hợp những bài toán con đó.</p> <p>Ví dụ với <code>n = 3, S = 11, W = [1, 3, 5]</code>.</p> <ul> <li>Bắt đầu với bài toán con <code>0</code> ta có <code>dp(0) = 0</code></li> <li>Với bài toán con <code>1</code>, có 1 đồng xu (nặng 1) có thể thêm vào từ <code>0</code> đồng xu nào cả. Vậy <code>dp(1) = dp(0) + 1 = 1</code>.</li> <li>Với bài toán con <code>2</code>, cũng chỉ có 1 đồng xu (nặng 1) có thể thêm vào từ <code>1</code> đồng xu. Vậy <code>dp(2) = dp(1) + 1 = 2</code>.</li> <li>Với bài toán con <code>3</code>, chúng ta có thể thêm 1 đồng xu 3 vào <code>0</code> đồng xu hoặc thêm 1 đồng xu 1 vào <code>2</code> đồng xu. Rõ ràng là cách đầu tiên cho kết quả nhỏ hơn. Vậy <code>dp(3) = min(dp(2) + 1, dp(0) + 1) = min(3, 1) = 1</code></li> <li>...</li> <li>Cứ tiếp tục như vậy cho đến bài toán <code>S</code> chính là đáp án chúng ta cần tìm.</li> </ul> <p>Về mặt cài đặt, quy hoạch động thường lưu kết quả vào một mảng. Trong ví dụ của chúng ta, mảng <code>dp[0..S]</code> sẽ lưu kết quả cho từng bài toán con. Nói cách khác, <code>dp[P] = k</code> nghĩa là cần ít nhất <code>k</code> đồng xu để có khối lượng là <code>P</code> Toàn bộ mảng này sẽ được tính bằng vòng lặp. Đoạn code sau mô tả toàn bộ quá trình này.</p> <div class=codehilite><pre><span></span><span class=n>n</span><span class=p>,</span> <span class=n>S</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
<span class=n>w</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>
<span class=n>dp</span> <span class=o>=</span> <span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>S</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span>
<span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>

<span class=k>for</span> <span class=n>P</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>S</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
    <span class=n>dp</span><span class=p>[</span><span class=n>P</span><span class=p>]</span> <span class=o>=</span> <span class=nb>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>P</span> <span class=o>-</span> <span class=n>x</span><span class=p>]</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=n>w</span> <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;=</span> <span class=n>P</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>

<span class=nb>print</span><span class=p>(</span><span class=n>dp</span><span class=p>)</span>
<span class=nb>print</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>S</span><span class=p>])</span>

<span class=c1># Nếu đầu vào như sau: n = 3, S = 11, w = [1, 3, 5]</span>
<span class=c1># Thì bảng lời giải cho các bài toán con sẽ lần lượt như sau:</span>
<span class=c1># P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11</span>
<span class=c1># ------+--+--+--+--+--+--+--+--+--+--+--</span>
<span class=c1># k = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3</span>
</pre></div> <h2 id=vi-du-2-xau-con-chung-dai-nhat-lcs>Ví dụ 2: Xâu con chung dài nhất (LCS)<a class=headerlink href=#vi-du-2-xau-con-chung-dai-nhat-lcs title="Permanent link">&para;</a></h2> <p>Thêm một ví dụ nữa cho dễ, cũng là một bài toán rất nổi tiếng.</p> <blockquote> <p>Cho hai xâu ký tự. Tìm độ dài xâu con chung nhỏ nhất giữa chúng. Ví dụ với 2 xâu "quetzalcoatl" và "tezcatlipoca" thì xâu con chung dài nhất sẽ là "ezaloa" với độ dài 6.</p> </blockquote> <p>Với bài toán này, chúng ta sẽ lần lượt giải các bài toán con như sau:</p> <p>Lấy i ký tự đầu tiên từ xâu thứ nhất và j ký tự đầu tiên từ xâu thứ hai và tìm độ dài xâu chung dài nhất giữa 2 xâu con được lấy ra đó. Dễ dàng thấy được rằng, lời giải của mỗi bài toán con sẽ phụ thuộc vào i và j, <code>dp(i, j)</code>. Và bài toán lớn sẽ được giải bằng cách lần lượt giải các bài toán con lần lượt từ <code>dp(0, 0)</code> và tăng dần độ dài xâu được lấy ra cho đến khi chúng ta lấy ra toàn bộ xâu của đề bài.</p> <p>Chúng ta hãy bắt đầu lần lượt các bài toán con. Đương nhiên, nếu một trong hai xâu là rỗng thì xâu con chung của chúng cũng rỗng. Vậy <code>dp(0, j) = dp(i, 0) = 0</code>. Nếu cả i và j đều dương, chúng ta cần suy xét một vài trường hợp.</p> <ol> <li>Nếu ký tự cuối cùng của xâu thứ nhất không có mặt trong xâu con chung dài nhất, nó có thể bị bỏ qua mà không ảnh hưởng gì đến kết quả. Công thức ở đây sẽ là <code>dp(i, j) = dp(i - 1, j)</code>.</li> <li>Tương tự như trường hợp trên, ký tự cuối cùng của xâu thứ hai không ảnh hưởng đến kết quả thì <code>dp(i, j) = dp(i, j - 1)</code>.</li> <li>Trường hợp cuối cùng, nếu hai ký tự cuối cùng của hai xâu <code>x1, x2</code> đều có mặt trong xâu con chung dài nhất. Dĩ nhiên là hai ký tự này phải là một thì điều này mới xảy ra, tức là <code>x1 == x2</code>. Trong trường hợp này, khi xoá đi bất cứ một ký tự nào trong hai ký tự đó đều khiến xâu con chung dài nhất ngắn đi 1 ký tự. Vậy rõ ràng là <code>dp(i, j) = dp(i - 1, j - 1) + 1</code>.</li> </ol> <p>Trong cả ba trường hợp trên, chúng ta phải chọn ra trường hợp nào cho kết quả là xâu con chung dài nhất (với bài toán này thì chỉ cần đưa ra độ dài đó là đủ).</p> <p>Về mặt cài đặt, <code>dp</code> sẽ được lưu trong mảng hai chiều. Kết quả của mảng này sẽ được tính toán thông qua vòng lặp hai lớp. Lưu ý rằng, chúng ta cần thực hiện vòng lặp sao cho chúng ta sẽ giải lần lượt từng bài toán con một, theo thứ tự từ nhỏ đến lớn. Bởi vì mỗi bài toán con <code>dp(i, j)</code> đều phụ thuộc vào các bài toán con trước đó <code>dp(i - 1, j), dp(i, j - 1), dp(i - 1, j - 1)</code>.</p> <div class=codehilite><pre><span></span><span class=n>n1</span><span class=p>,</span> <span class=n>n2</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
<span class=n>s1</span><span class=p>,</span> <span class=n>s2</span> <span class=o>=</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
<span class=n>t</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s2</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>s1</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
<span class=k>for</span> <span class=n>i</span><span class=p>,</span> <span class=n>x1</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=mi>1</span><span class=p>):</span>
    <span class=k>for</span> <span class=n>j</span><span class=p>,</span> <span class=n>x2</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=mi>1</span><span class=p>):</span>
        <span class=k>if</span> <span class=n>x1</span> <span class=o>==</span> <span class=n>x2</span><span class=p>:</span>
            <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=nb>max</span><span class=p>(</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>t</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>

<span class=nb>print</span><span class=p>(</span><span class=n>t</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>

<span class=c1># Kết quả khi giải các bài toán con như bảng sau:</span>
<span class=c1>#</span>
<span class=c1>#    S|    t  e  z  c  a  t  l  i  p  o  c  a</span>
<span class=c1># T ji| 0  1  2  3  4  5  6  7  8  9 10 11 12</span>
<span class=c1># ----+--------------------------------------</span>
<span class=c1>#  0 | 0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class=c1># q 1 | 0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class=c1># u 2 | 0  0  0  0  0  0  0  0  0  0  0  0  0</span>
<span class=c1># e 3 | 0  0  1  1  1  1  1  1  1  1  1  1  1</span>
<span class=c1># t 4 | 0  1  1  1  1  1  2  2  2  2  2  2  2</span>
<span class=c1># z 5 | 0  1  1  2  2  2  2  2  2  2  2  2  2</span>
<span class=c1># a 6 | 0  1  1  2  2  3  3  3  3  3  3  3  3</span>
<span class=c1># l 7 | 0  1  1  2  2  3  3  4  4  4  4  4  4</span>
<span class=c1># c 8 | 0  1  1  2  3  3  3  4  4  4  4  5  5</span>
<span class=c1># o 9 | 0  1  1  2  3  3  3  4  4  4  5  5  5</span>
<span class=c1># a 10| 0  1  1  2  3  4  4  4  4  4  5  5  6</span>
<span class=c1># t 11| 0  1  1  2  3  4  5  5  5  5  5  5  6</span>
<span class=c1># l 12| 0  1  1  2  3  4  5  6  6  6  6  6  6</span>
</pre></div> <h1 id=quy-hoach-ong-vs-memoization>Quy hoạch động vs. Memoization<a class=headerlink href=#quy-hoach-ong-vs-memoization title="Permanent link">&para;</a></h1> <p>Có một kỹ thuật khác gọi là "memoization" cũng có cách tiếp cận tương tự với quy hoạch động. Cả quy hoạch động và memoization đều dùng để tối ưu các vòng lặp mà có tính toán tượng tự nhau, trong đó kết quả của phép tính lớn hơn sẽ cần được tính toán dựa vào kết quả của phép tính nhỏ hơn. Memoization thường được sử dụng trong các phép tính đệ quy khi mà một tính toán bị lặp đi lặp lại nhiều lần. Nó sẽ lưu một bảng các giá trị tính được, mỗi khi có tính toán cần thực hiện, chúng ta sẽ tra bảng đó trước. Nếu bảng đã có kết quả rồi, chúng ta chỉ cần lấy ra là xong, nếu chưa, chúng ta sẽ tính toán như thường và tiếp tục lưu vào bảng.</p> <p>Memoization không phải là một thuật toán theo đúng nghĩa, nó là một kỹ thuật được sử dụng trong lập trình thì đúng hơn. Để hiểu rõ hơn về kỹ thuật này, mình xin lấy ví dụ ngay với bài toán Fibonacci. Chúng ta sẽ sử dụng memoization như sau:</p> <div class=codehilite><pre><span></span><span class=n>look_up</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span>
<span class=k>def</span> <span class=nf>fib</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>look_up</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=ow>is</span> <span class=kc>None</span><span class=p>:</span>
        <span class=n>look_up</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>=</span> <span class=n>fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>+</span> <span class=n>fib</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>look_up</span><span class=p>[</span><span class=n>n</span><span class=p>]</span>
</pre></div> <p>Sự khác biệt chủ yếu là quy hoạch động sẽ thực hiện việc tính toán theo một thứ tự định trước, trong khi memoization duyệt theo chiều sâu. Quy hoạch động không bao giờ tính toán một bài toán con hai lần, tương đối giống với các phép tính đệ quy với memoization. Tuy nhiên memoization thì không bao giờ tính toán những phép tính thừa trong khi quy hoạch động sẽ cần tất cả mọi bài toán con. Đây là một phương pháp khá hay, nó chỉ tính toán những gì cần thiết và lưu kết quả này lại để sau này dùng lại khi nào được gọi mà không cần tính toán nữa.</p> <p>Dưới đây là một số ưu, nhược điểm của memoization khi so sánh với quy hoạch động:</p> <p><strong> Ưu điểm </strong></p> <ul> <li>Dễ code hơn</li> <li>Không yêu cầu thứ tự thực hiện tính toán</li> <li>Chỉ tính toán những gì cần thiết</li> </ul> <p><strong> Nhược điểm </strong></p> <ul> <li>Chỉ có một kiểu duyệt duy nhất</li> <li>Thường chậm hơn quy hoạch động.</li> </ul> <h1 id=cac-dang-toan-quy-hoach-ong>Các dạng toán quy hoạch động<a class=headerlink href=#cac-dang-toan-quy-hoach-ong title="Permanent link">&para;</a></h1> <p>Phần lớn các bài toán quy hoạch động có thể chia làm hai loại: bài toán cần quy hoạch động để tối ưu và bài toán quy tổ hợp. Trong những phần dưới đây, chúng ta sẽ xem xét từng loại bài toán này.</p> <h2 id=bai-toan-toi-uu>Bài toán tối ưu<a class=headerlink href=#bai-toan-toi-uu title="Permanent link">&para;</a></h2> <p>Bài toán tối ưu yêu cầu chúng ta phải tìm đáp án tốt nhất từ mục tiêu của bài toán. Cả hai ví dụ mình đưa ra ở trên đều thuộc loại bài toán này (một bài tìm số đồng xu <strong>ít nhất</strong>, một bài tìm xâu con <strong>dài nhất</strong>). Mối liên hệ của các bài toán con thuộc dạng này có công thức chúng là <code>dp[s] = min(F1(dp[i], dp[j], ..., dp[k]), F2(dp[u], dp[v], ..., dp[w]), ..., Fl(dp[q], dp[p], ..., dp[z]))</code>, trong đó <code>dp</code> mảng lưu kết quả của các bài toán con đó.</p> <p>Mỗi bài toán được giải dựa trên bài toán đã được giải trước đó. Đây chính là tính chất cấu trúc con tối ưu của mỗi bài toán. Với bài toán đồng xu, mỗi bài toán mới đều được giải bằng cách thêm đúng 1 đồng xu vào kết quả từ trước đó. Kết quả cuối cùng là kết quả tốt nhất thu được từ nhiều cách thêm đồng xu với khối lượng khác nhau.</p> <p>Trước khi tính toán, mảng chứa kết quả có thể được điền đầy một giá trị trung tính nào đó. Giá trị trung tính có nghĩa là giá trị đó sẽ không bao giờ là đáp án cho bất kỳ bài toán con nào. Ví dụ khi cần tìm ra số đồng xu nhỏ nhất, chúng ta có thể điền mảng này bằng số dương lớn nhất, mọi tính toán tiếp theo sẽ cho ra một kết quả nhỏ hơn nhiều. Nếu không ra kết quả nào khác, chúng ta có thể coi như là không có một đáp án nào cho bài toán con đó.</p> <h2 id=bai-toan-to-hop>Bài toán tổ hợp<a class=headerlink href=#bai-toan-to-hop title="Permanent link">&para;</a></h2> <p>Bài toán tổ hợp thường yêu cầu chúng ta tìm ra số cách khác nhau để thực hiện một việc gì đó. Nhiều bài thi code thường có kết quả rất lớn và họ yêu cầu chúng ta đưa đáp án dạng modulo của 10000007. Trong dạng bài toán này, công thức khi xây dựng các bài toán con sẽ là <code>R[s] = F1(R[i], R[j], ..., R[k]) + F2(R[u], R[v], ..., R[w]) + ... + Fl(R[q], R[p], ..., R[z])</code>. Sự khác biệt cơ bản của dạng bài toán này với dạng bài toán tối ưu là ở chỗ chúng ta cần tính tổng thay vì tìm số lớn nhất hoặc nhỏ nhất.</p> <p>Trong mọi bài toán quy hoạch động, tính chất cấu trúc con tối ưu luôn là quan trọng nhất và cũng là tính chất khó đảm bảo nhất. Nếu cấu trúc con không được tối ưu, chúng ta sẽ tính toán theo một phương thức sai lầm và đương nhiên, kết quả thu được cũng không chính xác.</p> <p>Với phần lớn các bài toán quy hoạch động, việc chia các bài toán con gối nhau khá dễ dàng trong khi đảm bảo cấu trúc con tối ưu thì khó hơn nhiều.</p> <p>Mình sẽ đưa ra hai ví dụ tương tự nhau cho các bạn hiểu rõ hơn về những khó khăn để đảm bảo tính chất này.</p> <p>Vẫn với bài toán đồng xu, chúng ta sẽ thay đổi một chút để có bài toán tổ hợp như sau:</p> <blockquote> <p>Tìm số cách khác nhau để chọn ra các đồng xu sao cho tổng khối lượng của chúng là <code>S</code>.</p> </blockquote> <p>Các bài toán con sẽ tương tự như trước: <code>dp(P) = k</code> là số cách khác nhau để chọn ra các đồng xu có tổng khối lượng là <code>P</code>. Công thức đệ quy trong trường hợp này sẽ biến đổi theo bài toán như sau:</p> <div class=codehilite><pre><span></span><span class=c1># Công thức đệ quy cho bài toán quy hoạch động</span>
<span class=c1>#   {dp[0] = 1;</span>
<span class=c1>#   {dp[P] = sum(dp[P-Wi]);   (for Wi &lt;= P)</span>
<span class=c1>#</span>
<span class=c1># Với đầu vào như sau: n = 3, S = 11, W = [1, 3, 5]</span>
<span class=c1># Mảng kết quả quy hoạch động sẽ là</span>
<span class=c1>#  P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11</span>
<span class=c1>#  ------+--+--+--+--+--+--+--+--+--+--+--</span>
<span class=c1>#  k = 1 |1 |1 |2 |3 |5 |8 |12|19|30|47|74</span>
</pre></div> <p>Bài toán tổ hợp cũng có thể có một giá trị trung tính. Bởi vì bài toán tổ hợp thường tính tổng, giá trị trung tính sẽ là <code>0</code>. Bài toán tổ hợp yêu cầu tìm số cách khác nhau để làm gì đó, do đó giá trị <code>0</code> sẽ không ảnh hưởng gì đến đáp án. Một điểm đặc biệt quan trọng trong bài toán tổ hợp này là mỗi cách chúng ta chỉ tính đúng một lần. Nói thì dễ nhưng nhiều khi trong thực hành chúng ta hay gặp sai sót ở chỗ cực kỳ quan trọng này.</p> <p>Tiếp tục thay đổi thêm một chút, chúng ta sẽ có bài toán tổ hợp như sau:</p> <blockquote> <p>Tìm số cách khác nhau để chọn ra các đồng xu sao cho tổng khối lượng của chúng là <code>S</code>. Với điều kiện, các cách lấy đồng xu là hoán vị của nhau không được coi là khác nhau.</p> </blockquote> <p>Bài toán này khó hơn bài toán trước một chút. Nếu chúng vẫn chia các bài toán con như cũ thì không thể có được cấu trúc con tối ưu. Ví dụ, với các đồng xu 1, 3, 5 thì <code>(1, 3)</code> và <code>(3, 1)</code> đều cho kết quả là 4 nhưng chỉ được coi là 1 cách.</p> <p>Với bài toán này, chúng ta sẽ chia bài toán lớn thành các bài toán con theo một cách tương đối khác. Chúng ta thấy rằng, kết quả (số cách chọn đồng xu) sẽ là tổng hợp của hai kết quả:</p> <ul> <li>Số cách lấy đồng xu từ <code>n - 1</code> đồng xu đầu tiên, tức là chúng ta coi như không có đồng xu nặng nhất</li> <li>Số cách lấy đồng xu có chứa đồng xu nặng nhất.</li> </ul> <p>Kết quả sẽ là tổng của hai kết quả trên. Các bạn thấy đó, với cách xây dựng bài toán con như thế này, chúng ta đã xây dựng các bài toán con gối nhau mà vẫn đảm bảo cấu trúc con tối ưu (kết quả bằng tổng của các bài toán con).</p> <p>Nhân tiện, với cách chia bài toán như vậy, chúng ta có thể thu được lời giải bằng cách đệ quy đơn giản như sau:</p> <div class=codehilite><pre><span></span><span class=n>n</span><span class=p>,</span> <span class=n>S</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
<span class=n>w</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>


<span class=k>def</span> <span class=nf>count</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>x</span><span class=p>):</span>
    <span class=c1># Có 1 cách (lấy ra 0 đồng xu) cho tổng khối lượng bằng 0</span>
    <span class=k>if</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=mi>1</span>
    <span class=c1># Không thể lấy được các đồng xu cho khối lượng âm</span>
    <span class=k>if</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>:</span>
        <span class=k>return</span> <span class=mi>0</span>
    <span class=c1># Không thể lấy nếu không có đồng xu nào</span>
    <span class=k>if</span> <span class=ow>not</span> <span class=n>arr</span> <span class=ow>and</span> <span class=n>x</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>:</span>
        <span class=k>return</span> <span class=mi>0</span>
    <span class=c1># Kết quả là tổ hợp các bài toán con</span>
    <span class=k>return</span> <span class=n>count</span><span class=p>(</span><span class=n>arr</span><span class=p>[:</span><span class=o>-</span><span class=mi>1</span><span class=p>],</span> <span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=n>count</span><span class=p>(</span><span class=n>arr</span><span class=p>,</span> <span class=n>x</span> <span class=o>-</span> <span class=n>arr</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>


<span class=nb>print</span><span class=p>(</span><span class=n>count</span><span class=p>(</span><span class=n>w</span><span class=p>,</span> <span class=n>S</span><span class=p>))</span>
</pre></div> <p>Tuy nhiên, như mình đã nói ở phần trước, nếu bạn đang thi code, cách làm này sẽ không mang lại bất cứ hy vọng đạt giải nào, do nó cực kỳ mất thời gian và bộ nhớ. Tuy nhiên, chúng ta có thể áp dụng quy hoạch động cho bài toán này rất dễ dàng sau khi có được cấu trúc con tối ưu với các bài toán con gối nhau:</p> <div class=codehilite><pre><span></span><span class=n>n</span><span class=p>,</span> <span class=n>S</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
<span class=n>w</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()))</span>

<span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>)]</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>S</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>
<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
    <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span>

<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>S</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span><span class=p>):</span>
        <span class=n>x</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>w</span><span class=p>[</span><span class=n>j</span><span class=p>]][</span><span class=n>j</span><span class=p>]</span> <span class=k>if</span> <span class=n>i</span> <span class=o>-</span> <span class=n>w</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=k>else</span> <span class=mi>0</span>
        <span class=n>y</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=k>if</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>1</span> <span class=k>else</span> <span class=mi>0</span>
        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>


<span class=nb>print</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=o>-</span><span class=p>][</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>])</span>
<span class=c1># Kết quả tính toán với n = 3, w = [1, 3, 5] như sau:</span>
<span class=c1>#  S = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11</span>
<span class=c1>#  ------+--+--+--+--+--+--+--+--+--+--+--</span>
<span class=c1>#  k = 1 |1 |1 |2 |2 |3 |4 |4 |5 |6 |7 |8</span>
</pre></div> <p>Các bạn thấy đó, xây dựng các bài toán con gối nhau sao cho cấu trúc con vẫn tối ưu nhiều khi không đơn giản chút nào. Và mỗi bài toán quy hoạch động lại có những biến hóa khác nhau mà không theo một khuôn mẫu khô cứng nào. Ngay cả khi bạn có thể giải được rất nhiều bài toán quy hoạch động rồi, không gì có thể đảm bảo bạn có thể giải được các bài khác nữa. Đó cũng là một lý do khiến cho dạng bài này luôn "hot" trong các cuộc thi.</p> <h1 id=quy-hoach-ong-xuoi-va-nguoc>Quy hoạch động xuôi và ngược<a class=headerlink href=#quy-hoach-ong-xuoi-va-nguoc title="Permanent link">&para;</a></h1> <p>Tất cả những ví dụ mình đã trình bày ở trên đều sử dụng quy hoạch động kiểu “ngược”. Ngược ở đây không phải là chúng ta duyệt các bài toán con từ lớn ngược về nhỏ. Mà quy trình sẽ như thế này: Duyệt qua tất cả các bài toán con (từ nhỏ đến lớn), với mỗi bài toán đó, chúng ta tính toán kết quả dựa vào bài toán con trước đó. Tất nhiên, bài toán con phía trước đã được giải theo quy trình duyệt, và với mỗi bài toán, chúng ta phải “nhìn ngược lại” bài toán trước đó, nên cách làm này gọi là quy hoạch động kiểu “ngược”.</p> <p>Phương pháp quy hoạch động ngược này được sử dụng rộng rãi, vì nó khá tương ứng với suy nghĩ tự nhiên của chúng ta. Chúng ta đọc đề bài, suy nghĩ cách giải cho nó. Cách giải đó yêu cầu phải giải những bài toán nhỏ hơn, như kiểu làm toán ngày phải chứng minh các bổ đề vậy. Chúng ta tiếp tục suy nghĩ cho những bài toán con này, rồi tổng hợp để tìm ra lời giải cho bài toán lớn. Quá trình cứ tiếp tục như vậy, và quy hoạch động kiểu “ngược” này đang được xây dựng đúng như vậy.</p> <p>Ngoài ra, về mặt lập trình, kiểu quy hoạch động này có mối quan hệ tương đối gần gũi với đệ quy. Một bài toán lớn được giải dựa vào các bài toán con tương tự nhau (và tương tự bài toán lớn) thì việc áp dụng đệ quy có thể là một phương pháp dễ dàng để code. Vì vậy, nhiều trường hợp, có thể coi quy hoạch động là một cách để tối ưu phương pháp đệ quy để giải một bài toán.</p> <p>Ngoài kiểu quy hoạch động ngược này, có một kiểu quy hoạch động “xuôi”. Tuy không phổ biến, kiểu quy hoạch động xuôi cũng khá khó áp dụng, nhưng quy hoạch động “xuôi” mang đến cho chúng ta nhiều tiện lợi. Kiểu xuôi này cũng cần duyệt qua các bài toán con từ nhỏ đến lớn, nhưng với mỗi bài toán con, chúng ta tính toán kết quả và từ đó tìm cách thực hiện một số phép tính để giải bài toán lớn hơn. Nghĩa là, với mỗi bài toán con, chúng ta sẽ nhìn về phía trước để xem phải giải bài toán tiếp theo như thế này từ bài toán hiện tại.</p> <p>Phương pháp này khó áp dụng hơn phương pháp ngược kia, và cũng không phải bài toán nào cũng áp dụng được. Với mỗi bài toán, việc xác định bước tiếp theo tương đối khó khăn, thậm chí việc kiểm tra tính đúng sai của phương pháp cũng không hề dễ dàng.</p> <p>Như chúng ta đã thấy ở những phần trước, thông thường, mỗi bài toán cần phải giải bằng cách tổng hợp kết quả từ một vài bài toán con trước đó. Vì vậy, cách quy hoạch động xuôi này chỉ sử dụng một bài toán con để tính toán trước bài toán tiếp theo sẽ chỉ cho ra một phần của kết quả chứ không phải kết quả cuối cùng. Vì vậy, để thực hiện quy hoạch động xuôi, việc điền sẵn một mảng các giá trị trung tính là điều bắt buộc (sau đó chúng ta sẽ cộng dồn kết quả vào mỗi khi giải được một bài toán con mới).</p> <p>Mình lấy vị với bài toán xâu con chung dài nhất. Với bài toán này, chúng ta có thể chọn giá trị trung tính là một số âm. Chúng ta sẽ tìm cách quy hoạch động xuôi như sau:</p> <ul> <li><code>dp(0,0) = 0</code> là bài toán với hai xâu rỗng</li> <li>Với mỗi bài toán <code>dp(i, j)</code> chúng ta sẽ tìm cách tính toán kết quả cho các bài toán lớn hơn. Lúc này, có 3 hướng phát triển tiếp:<ol> <li>Lấy thêm một ký tự từ xâu thứ nhất =&gt; Kết quả không thay đổi.</li> <li>Lấy thêm một ký tự từ xâu thứ hai =&gt; Kết quả cũng không thay đổi.</li> <li>Nếu ký tự tiếp theo của cả hai xâu giống nhau =&gt; Lấy tự từ này và độ dài xâu con chung tăng lên 1.</li> </ol> </li> </ul> <p>Dưới đây là code cho bài toán này:</p> <div class=codehilite><pre><span></span><span class=n>n1</span><span class=p>,</span> <span class=n>n2</span> <span class=o>=</span> <span class=nb>map</span><span class=p>(</span><span class=nb>int</span><span class=p>,</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>())</span>
<span class=n>s1</span><span class=p>,</span> <span class=n>s2</span> <span class=o>=</span> <span class=nb>input</span><span class=p>()</span><span class=o>.</span><span class=n>split</span><span class=p>()</span>
<span class=n>s1</span> <span class=o>+=</span> <span class=s1>&#39;</span><span class=se>\0</span><span class=s1>x00&#39;</span>
<span class=n>s2</span> <span class=o>+=</span> <span class=s1>&#39;</span><span class=se>\0</span><span class=s1>x00&#39;</span>

<span class=c1># Điền sẵn giá trị trung tính</span>
<span class=n>dp</span> <span class=o>=</span> <span class=p>[[</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=p>(</span><span class=n>n1</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)</span> <span class=k>for</span> <span class=n>_</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n2</span> <span class=o>+</span> <span class=mi>2</span><span class=p>)]</span>
<span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span>

<span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n1</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
    <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n2</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
        <span class=n>tres</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span>
        <span class=c1># Phát triển theo hướng thứ nhất</span>
        <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>tres</span><span class=p>:</span>
            <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>tres</span>
        <span class=c1># Phát triển theo hướng thứ hai</span>
        <span class=k>if</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>tres</span><span class=p>:</span>
            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>tres</span>
        <span class=c1># Phát triển theo hướng thứ ba</span>
        <span class=k>if</span> <span class=n>s1</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s2</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=ow>and</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>tres</span> <span class=o>+</span> <span class=mi>1</span><span class=p>:</span>
            <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>tres</span> <span class=o>+</span> <span class=mi>1</span>

<span class=nb>print</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>n1</span><span class=p>][</span><span class=n>n2</span><span class=p>])</span>
</pre></div> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Hy vọng qua bài viết này, mình đã trình bày được phần nào về phương pháp quy hoạch động. Về cơ bản, với mọi bài toán quy hoạch động, chúng ta có thể xây dựng các bài toán con gối nhau với cấu trúc con tối ưu là 90% công việc đã hoàn thành.</p> <p>Tuy nhiên, cũng cần hiểu rằng, mặc dù quy hoạch động là một thuật toán thần thánh, nó có thể giải được rất nhiều bài toán, nhưng nó không phải là chìa khóa vạn năng. Có một điều rất hiển nhiên: phương pháp tốt nhất để giải quyết mọi bài toán trong tin học là biết sử dụng và phối hợp uyển chuyển nhiều thuật toán, chúng ta không nên phát cuồng một thuật toán và cũng không nên coi thường bất cứ một thuật toán nào.</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#algorithm</span> <span>#contest</span> <span>#dynamic programming</span> <span>#dp</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2017/Sep/24/practise-programming-python-with-python-challenge.html> Newer Post </a> </span> <span class=older-link> <a href=/2017/Jul/24/python-tricks-you-have-to-know-when-you-go-pro.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>