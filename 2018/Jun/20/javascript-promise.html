<!DOCTYPE html><title>Javascript: Promise - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="JavaScript là một ngôn ngữ lập trình phía client, giúp chúng ta có những ứng dụng web đẹp hơn, thao tác dễ hơn, hiệu ứng cool hơn. Tuy nhiên, cách thức hoạt động của JavaScript hơi đặc thù một chút. Rất nhiều hoạt động của nó đều ở dạng bất …"> <meta name=keywords content="JavaScript, Promise, async, await, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Javascript: Promise - manhhomienbienthuy's space"> <meta name=twitter:description content="JavaScript là một ngôn ngữ lập trình phía client, giúp chúng ta có những ứng dụng web đẹp hơn, thao tác dễ hơn, hiệu ứng cool hơn. Tuy nhiên, cách thức hoạt động của JavaScript hơi đặc thù một chút. Rất nhiều hoạt động của nó đều ở dạng bất …"> <meta name=twitter:image content=/https://i.imgur.com/3EG0L91.jpg> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Javascript: Promise </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on June 20, 2018 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2018/Jun/20/javascript-promise.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/3EG0L91.jpg alt="Javascript: Promise"> <p>JavaScript là một ngôn ngữ lập trình phía client, giúp chúng ta có những ứng dụng web đẹp hơn, thao tác dễ hơn, hiệu ứng cool hơn. Tuy nhiên, cách thức hoạt động của JavaScript hơi đặc thù một chút. Rất nhiều hoạt động của nó đều ở dạng bất đồng bộ (asynchronous).</p> <p>Vì vậy, việc kiểm soát code để nó có thể hoạt động trơn tru cũng không phải là việc đơn giản. Trong bài viết này, chúng ta sẽ tìm hiểu những phương thức mới được giới thiệu từ ECMAScript 2015 trở đi, giúp chúng ta code JavaScript bất đồng bộ được dễ dàng hơn.</p> <h1 id=cach-truyen-thong-dung-callback>Cách truyền thống: dùng callback<a class=headerlink href=#cach-truyen-thong-dung-callback title="Permanent link">&para;</a></h1> <p>Callback là tên mà chúng ta dùng để gọi các hàm JavaScript trong một trường hợp đặc biệt. Rất khó để định nghĩa chúng nhưng có thể rất dễ hiểu thông qua ví dụ dưới đây. Callback chỉ là tên được cộng động dùng, nó không có gì đặc biệt trong ngôn ngữ này cả.</p> <p>Thuật ngữ bất đồng bộ (asynchronous, hoặc gọi ngắn là async) có thể hiểu rằng "sẽ mất một chút thời gian", "sẽ hoàn thành trong tương lai, không phải bây giờ". Callback là phương án được sử dụng phổ biến trong những hoạt động bất đồng bộ này.</p> <p>Hoạt động bất đồng bộ của JavaScript diễn ra rất thường xuyên. Là một lập trình viên web, chắc hẳn bạn đã rất quen thuộc với những truy vấn kiểu ajax. Chúng ta có thể xem xét một ví dụ thực tế như sau:</p> <div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>loadScript</span><span class=p>(</span><span class=nx>src</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>script</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;script&#39;</span><span class=p>);</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>src</span><span class=p>;</span>
    <span class=nb>document</span><span class=p>.</span><span class=nx>head</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Mục đích của hàm trên là để load một file JavaScript bằng JavaScript. Sau khi chạy hàm này, nó sẽ chèn thêm một thẻ <code>&lt;script src="${src}"&gt;&lt;/script&gt;</code> vào trong <code>head</code>, sau đó trình duyệt sẽ tải file này về và thực thi.</p> <p>Cách sử dụng nó rất đơn giản:</p> <div class=codehilite><pre><span></span><span class=c1>// loads and executes the script</span>
<span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;/my_script.js&#39;</span><span class=p>);</span>
</pre></div> <p>Hàm này hoạt động một cách bất đồng bộ, bởi vì việc tải file script sẽ mất một chút thời gian. Việc gọi hàm sẽ bất đầu việc load script, việc load này sẽ được trình duyệt thực hiện "ngầm" bởi một tiến trình khác. Những code phía dưới hàm này sẽ tiếp tục được thực thi mà không cần đợi script được load. Thâm chí, nó có thể kết thúc trước cả việc script được load xong.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;/my_script.js&#39;</span><span class=p>);</span>
<span class=c1>// Code dưới này sẽ được thực thi ngay là không chờ script load xong</span>
</pre></div> <p>Việc hoạt động bất đồng bộ này không phải là vấn đề, chúng ta hoàn toàn không cần quan tâm. Tuy nhiên, có một vài trường hợp, khi load script mới, nó định nghĩa một số hàm và biến, và chúng ta cần sử dụng lại những thứ này. Điều này thường gặp khi chúng ta sử dụng các thư viện, như jQuery chẳng hạn:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>);</span>
<span class=nx>$</span><span class=p>(</span><span class=s2>&quot;#test&quot;</span><span class=p>).</span><span class=nx>hide</span><span class=p>();</span>
</pre></div> <p>Rất tự nhiên, trình duyệt sẽ cần thời gian để tải thư viện jQuery về. Tuy nhiên, nó lại không chờ cho script được tải về mà sẽ ngay lập tức thực hiện lệnh tiếp theo.</p> <p>Vì vậy, những code tiếp theo sẽ không thực thi được mà chúng ta sẽ gặp lỗi:</p> <div class=codehilite><pre><span></span><span class=nx>Uncaught</span> <span class=nx>ReferenceError</span><span class=o>:</span> <span class=nx>$</span> <span class=nx>is</span> <span class=nx>not</span> <span class=nx>defined</span>
</pre></div> <p>Với cách làm như trên, chúng ta chưa có cách nào theo dõi trạng thái của việc load script. Nhưng nếu chúng ta muốn sử dụng những hàm và biến được định nghĩa trong script, chúng ta cần sử dụng một phương thức khác. Truyền callback là một cách phổ thông nhất.</p> <div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>loadScript</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>callback</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>script</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;script&#39;</span><span class=p>);</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>src</span><span class=p>;</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=nx>callback</span><span class=p>;</span>
    <span class=nb>document</span><span class=p>.</span><span class=nx>head</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Bây giờ, muốn sử dụng những gì được định nghĩa trong script, chúng ta có thể cho vào callback:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
  <span class=c1>// callback được gọi sau khi script load xong</span>
  <span class=nx>$</span><span class=p>(</span><span class=s2>&quot;#test&quot;</span><span class=p>).</span><span class=nx>hide</span><span class=p>();</span>
  <span class=p>...</span>
<span class=p>});</span>
</pre></div> <p>Ý tưởng của việc này rất đơn giản, chúng ta truyền một hàm làm tham số của hàm khác, hàm này gọi là callback. Và hàm đó sẽ được gọi khi sau khi thực hiện xong một số đoạn code cần thiết. Đó cũng là phương thức xưa nay vẫn thường được sử dụng. Bất cứ một hàm nào hoạt động bất đồng bộ cũng cần cung cấp một tham số dành riêng cho việc truyền callback.</p> <h2 id=callback-long-nhau>Callback lồng nhau<a class=headerlink href=#callback-long-nhau title="Permanent link">&para;</a></h2> <p>Việc sử dụng callback như trên rất tốt. Nhưng mọi việc sẽ phức tạp hơn khi chúng ta cần load nhiều hơn một script.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;jQuery loaded&#39;</span><span class=p>);</span>
    <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;lodash 2 loaded&#39;</span><span class=p>);</span>
        <span class=p>...</span>
    <span class=p>})</span>
<span class=p>})</span>
</pre></div> <p>Với cách gọi callback lồng nhau như trên, sau khi script thứ nhất load xong, callback sẽ gọi việc load script thứ hai.</p> <p>Code như trên vẫn còn trông rất đẹp, nhưng nếu chúng ta có nhiều script hơn nữa thì sao:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script1.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script2.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script3.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
            <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script4.js&#39;</span><span class=p>,</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
                <span class=p>...</span>
            <span class=p>})</span>
        <span class=p>})</span>
    <span class=p>})</span>
<span class=p>})</span>
</pre></div> <p>Việc sử dụng callback lồng nhau vẫn ổn nếu chúng ta lồng nhau ít cấp. Nhưng khi mức độ lồng nhau tăng lên, rõ ràng là không thể dùng cách này được. Mọi việc sẽ còn phức tạp hơn nữa khi các hoạt động bất đồng bộ này không phải lúc nào cũng thành công.</p> <h2 id=xu-ly-khi-gap-loi>Xử lý khi gặp lỗi<a class=headerlink href=#xu-ly-khi-gap-loi title="Permanent link">&para;</a></h2> <p>Trong những ví dụ ở trên, chúng ta hoàn toàn không quan tâm đến trường hợp bị lỗi. Chúng ta nên nâng cấp code một chút để nó có thể xử lý thêm trường hợp này</p> <div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>loadScript</span><span class=p>(</span><span class=nx>src</span><span class=p>,</span> <span class=nx>callback</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>script</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;script&#39;</span><span class=p>);</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>src</span><span class=p>;</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>callback</span><span class=p>(</span><span class=kc>null</span><span class=p>,</span> <span class=nx>script</span><span class=p>);</span>
    <span class=nx>script</span><span class=p>.</span><span class=nx>onerror</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>callback</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;script not loaded&#39;</span><span class=p>));</span>
    <span class=nb>document</span><span class=p>.</span><span class=nx>head</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Việc sử dụng rất đơn giản, hàm được truyền làm callback cần có hai tham số, tham số thứ nhất là lỗi (nếu không có lỗi thì truyền vào <code>null</code>) và tham số thứ hai là script được load.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;my_script.js&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// Có lỗi xảy ra khi load script</span>

    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// Script đã load xong</span>
    <span class=p>}</span>
<span class=p>});</span>
</pre></div> <p>Việc định nghĩa callback như trên là theo phong cách <a href=https://stackoverflow.com/a/40512067>error-first callback</a>. Convention rất đơn giản: tham số đầu tiên dùng để truyền lỗi khi nó xảy ra. Những tham số tiếp theo dùng để truyền kết quả cho trường hợp bình thường (khi đó, tham số đầu tiên sẽ là <code>null</code>). Bằng cách này, chúng ta chỉ cần định nghĩa một callback cho cả trường hợp có lỗi và không.</p> <h2 id=callback-hell>Callback hell<a class=headerlink href=#callback-hell title="Permanent link">&para;</a></h2> <p>Những trường hợp ở trên, chúng ta đã xem xét cách sử dụng callback cho các hoạt động bất đồng bộ. Và trong trường hợp cần thiết, chúng ta cần phải sử dụng callback trong callback, thậm chí lồng nhau vài lớp. Nhưng càng lồng nhau nhiều, nguy cơ mất kiểm soát code sẽ càng tăng lên.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script1.js&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script2.js&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
            <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
                <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script3.js&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
                    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
                        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
                    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script4&#39;</span><span class=p>,</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
                            <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
                                <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
                            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
                                <span class=c1>// Code sau khi tất cả các hoạt động bất đồng</span>
                                <span class=c1>// bộ hoàn thành.</span>
                            <span class=p>}</span>
                        <span class=p>})</span>
                    <span class=p>}</span>
                <span class=p>})</span>
            <span class=p>}</span>
        <span class=p>})</span>
    <span class=p>}</span>
<span class=p>})</span>
</pre></div> <p>Vâng, phải nói là trông code rất đẹp. Mọi việc rất đơn giản theo flow như sau:</p> <ul> <li>Load <code>script1.js</code>, nếu không có lỗi thì tiếp tục.</li> <li>Load <code>script2.js</code>, nếu không có lỗi thì tiếp tục.</li> <li>Load <code>script3.js</code>, nếu không có lỗi thì tiếp tục.</li> <li>Load <code>script4.js</code>, nếu không có lỗi thì bắt đầu xử lý logic chúng ta cần.</li> </ul> <p>Với cách làm như thế này thì code có thể tiếp tục mở rộng thêm nữa mà không gặp vấn đề gì. Nhưng khi mọi thứ trở nên phức tạp hơn, việc lồng nhau mức độ cao hơn, đặc biệt, khi chúng ta có những code với vòng lặp, các câu lệnh điều kiện, rẽ nhánh, v.v... việc kiểm soát code sẽ trở nên cực kỳ khó khăn.</p> <p>Vấn đề này trong lập trình nói chung được gọi là <a href=http://calculist.org/blog/2011/12/14/why-coroutines-wont-work-on-the-web/ >pyramid of doom</a> (do code trông như xây kim tự tháp). Riêng trong JavaScript nó còn được gọi với tên gọi là khác <a href=http://thecodebarbarian.com/2015/03/20/callback-hell-is-a-myth>callback hell</a>.</p> <p>Nguyên nhân của callback hell là khi chúng ta cố gắng viết code JavaScript theo kiểu tuần tự như những ngôn ngữ khác. Nhưng vì đặc thù của hoạt động bất đồng bộ, nên việc tuần tự này không thể thực hiện được. Callback hell thường xảy ra ở những lập trình viên còn ít kinh nghiệm, tuy nhiên, kể cả người đã đi làm nhiều năm vẫn có thể gặp phải, bởi cấu trúc code lồng nhau thật quá phức tạp.</p> <p>Ví dụ với code ở trên thì mọi thứ vẫn chạy tốt, nhưng chỉ cần đóng mở ngoặc sai một ly thôi là đi luôn một dặm. <a href=http://callbackhell.com/ >Trang web này</a> có đưa ra một số phương án để phòng tránh callback hell cũng khá hay, có thể áp dụng được. Tuy nhiên, trong bài viết này, chúng ta sẽ tìm hiểu một phương án còn hay hơn nữa.</p> <p>Một cách đơn giản để trông code có vẻ đơn giản hơn, tránh code trông như kim tự tháp kia là định nghĩa các hàm và gọi chúng như sau:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script1.js&#39;</span><span class=p>,</span> <span class=nx>callbackAfterScript1</span><span class=p>);</span>

<span class=nx>callbackAfterScript1</span> <span class=o>=</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script2.js&#39;</span><span class=p>,</span> <span class=nx>callbackAfterScript2</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nx>callbackAfterScript2</span> <span class=o>=</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script3.js&#39;</span><span class=p>,</span> <span class=nx>callbackAfterScript3</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nx>callbackAfterScript3</span> <span class=o>=</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script4.js&#39;</span><span class=p>,</span> <span class=nx>callbackAfterScript4</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=nx>callbackAfterScript4</span> <span class=o>=</span> <span class=p>(</span><span class=nx>error</span><span class=p>,</span> <span class=nx>script</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>handleError</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=c1>// Code sau khi tất cả các hoạt động bất đồng</span>
        <span class=c1>// bộ hoàn thành.</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Bằng cách làm như trên, dù code không thay đổi về bản chất, nhưng kim tự tháp của chúng ta đã thấp đi đáng kể, bằng cách đó, callback hell sẽ khó xảy ra hơn. Mặc dù vậy, code này lại trở nên khó đọc hơn, để hiểu được hoạt động của nó, chúng ta phải do từ hàm này đến hàm khác. Nếu mức độ lồng nhau nhiều, thì việc làm này cũng tốn không ít thời gian.</p> <p>May mắn cho chúng ta, từ khi ECMAScript 2015 (ES 6) ra đời, chúng ta đã có phương án tốt hơn rất nhiều để giải quyết.</p> <h1 id=promise>Promise<a class=headerlink href=#promise title="Permanent link">&para;</a></h1> <p><a href=https://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor>Promise</a> được giới thiệu kể từ ECMAScript 2015. Đây là một điểm sáng giúp chúng ta giải quyết các logic bất đồng bộ một cách tốt hơn.</p> <p>Promise (lời hứa) có thể hiểu thế này: bạn hứa với mọi người sẽ làm việc XYZ và sẽ cho họ xem kết quả khi làm xong, nhưng bạn không biết chính xác khi nào thì sẽ xong. Họ cứ làm việc của họ trong lúc chờ đợi, khi công việc hoàn thành, bạn báo cho họ kết quả. Nếu chẳng may đại sự bất thành, bạn cũng thông báo cho họ không phải chờ nữa.</p> <p>Như vậy, lời hứa được đảm bảo, ai nấy đều vui vẻ cả. Promise cũng được thiết kế với ý tưởng tương tự như vậy.</p> <p>Một vài hoạt động bất đồng bộ, nó cần thời gian để hoàn thành, như ví dụ, đó là load một script khác. Rất nhiều code khác đang chờ công việc đó hoàn thành, promise là lời hứa mà loadScript đưa cho họ. Khi nào loadScript hoàn thành, những ai đang chờ sẽ được thông báo, kể cả load thất bại thì việc thất bại đó cũng được thông báo luôn.</p> <h2 id=tao-promise>Tạo promise<a class=headerlink href=#tao-promise title="Permanent link">&para;</a></h2> <p>Promise được tạo ra như sau:</p> <div class=codehilite><pre><span></span><span class=kd>let</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=c1>// code thực hiện logic</span>
<span class=p>});</span>
</pre></div> <p>Hàm được truyền vào để khởi tạo <code>Promise</code> được gọi là "executor". Hàm này sẽ được thực thi khi promise được tạo ra. Khi executor kết thúc, nó phải gọi một trong số hai hàm <code>resolve</code> và <code>reject</code>.</p> <ul> <li>Gọi <code>resolve</code> khi code chạy thành công, công việc kết thúc mà không có lỗi gì. Khi đó, <code>state</code> của đối tượng promise sẽ là <code>fulfilled</code> (trạng thái khởi tạo là <code>pending</code>), đồng thời <code>result</code> của đối tượng promise sẽ là giá trị của tham số được truyền cho <code>resolve</code>.</li> <li>Gọi <code>reject</code> nếu có lỗi xảy ra, khi đó <code>state</code> của đối tượng promise sẽ là <code>rejected</code>, đồng thời <code>result</code> cũng sẽ là tham số được truyền vào cho <code>reject</code>.</li> </ul> <p>Quay lại trường hợp loadScript ở trên, chúng ta sẽ chuyển sang dùng promise như sau, không cần phải truyền callback vào nữa.</p> <div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>loadScript</span><span class=p>(</span><span class=nx>src</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=kr>const</span> <span class=nx>script</span> <span class=o>=</span> <span class=nb>document</span><span class=p>.</span><span class=nx>createElement</span><span class=p>(</span><span class=s1>&#39;script&#39;</span><span class=p>);</span>
        <span class=nx>script</span><span class=p>.</span><span class=nx>src</span> <span class=o>=</span> <span class=nx>src</span><span class=p>;</span>
        <span class=nx>script</span><span class=p>.</span><span class=nx>onload</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
        <span class=nx>script</span><span class=p>.</span><span class=nx>onerror</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;script not loaded&#39;</span><span class=p>));</span>
        <span class=nb>document</span><span class=p>.</span><span class=nx>head</span><span class=p>.</span><span class=nx>append</span><span class=p>(</span><span class=nx>script</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>}</span>
</pre></div> <p>Giờ hàm này vẫn gọi như bình thường, còn callback đi đâu chúng ta sẽ tìm hiểu tiếp ở những phần tiếp theo.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>);</span>
</pre></div> <p>Việc thực thi sẽ diễn ra như sau:</p> <ul> <li>Executor sẽ được thực thi khi khởi tạo promise mới.</li> <li>Executor có hai tham số là <code>resolve</code> và <code>reject</code>, đây chính là hai hàm cần phải được gọi khi hoàn thành. Đây là hàm được cung cấp sẵn, chúng ta không cần quan tâm đến nó, chỉ cần sử dụng là được.</li> <li>Executor hoạt động và tuỳ vào kết quả nó sẽ gọi đến một trong hai hàm trên.</li> </ul> <p>Một lưu ý rằng, <code>resolve</code> hoặc <code>reject</code> chỉ có thể được gọi một lần. Dù chúng ta có gọi nhiều lần thì chỉ lần gọi đầu tiên có tác dụng:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;first resolve&#39;</span><span class=p>);</span>
    <span class=nx>reject</span><span class=p>(</span><span class=s1>&#39;error&#39;</span><span class=p>);</span>
    <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;second resolve&#39;</span><span class=p>)</span>
<span class=p>})</span>
<span class=c1>// trả về Promise {&lt;resolved&gt;: &quot;first resolve&quot;}</span>
<span class=c1>// gọi resolve, reject tiếp theo cũng không có tác dụng</span>
</pre></div> <p>Ngoài ra, các hàm <code>resolve</code> và <code>reject</code> có thể nhận số lượng tham số tuỳ ý, nhưng sẽ chỉ có tham số đầu tiên được sử dụng làm <code>result</code> cho đối tượng promise, những tham số tiếp theo sẽ bị bỏ qua. Hành động resolve hoạt reject promise này được gọi với thuật ngữ <code>settle</code> promise đó.</p> <p>Vậy là chúng ta đã tạo ra đối tượng promise, công việc bây giờ mà chúng ta cần là tìm cách gọi những code tiếp theo cần thực thi khi công việc bất đồng bộ này thành công. Đó cũng chính là nội dung của phần tiếp theo</p> <h2 id=su-dung-then-va-catch>Sử dụng <code>then</code> và <code>catch</code><a class=headerlink href=#su-dung-then-va-catch title="Permanent link">&para;</a></h2> <p>Promise cho phép chúng ta liên kết các hoạt động bất đồng bộ với những code cần thực thi (những code cần đến kết quả của hoạt động kia) sau đó rất dễ dàng. Những điều đó có thể thực hiện thông qua <code>.then</code> như sau:</p> <div class=codehilite><pre><span></span><span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span>
    <span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=c1>// Code trong trường hợp thành công</span>
    <span class=p>},</span>
    <span class=nx>error</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=c1>// Code trong trường hợp lỗi</span>
    <span class=p>}</span>
<span class=p>);</span>
</pre></div> <p>Tham số đầu tiên được thực thi khi promise được resolve và thành công, còn tham số thứ hai được gọi khi promise bị reject trong trường hợp lỗi.</p> <p>Với ví dụ <code>loadScript</code> ở trên, chúng ta có thể thực hiện đơn giản thế này:</p> <div class=codehilite><pre><span></span>    <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>)</span>
        <span class=p>.</span><span class=nx>then</span><span class=p>(</span>
            <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
                <span class=nx>$</span><span class=p>(</span><span class=s2>&quot;#test&quot;</span><span class=p>).</span><span class=nx>hide</span><span class=p>();</span>
            <span class=p>},</span>
            <span class=nx>error</span> <span class=p>=&gt;</span> <span class=p>{</span>
                <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>);</span>
</pre></div> <p>Nếu chúng ta chỉ cần quan tâm đến trường hợp thành công, còn lỗi thì bỏ qua, chúng ta chỉ cần dùng 1 tham số cho <code>then</code> là đủ:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>$</span><span class=p>(</span><span class=s2>&quot;#test&quot;</span><span class=p>).</span><span class=nx>hide</span><span class=p>();</span>
<span class=p>});</span>
</pre></div> <p>Nếu chúng ta chỉ quan tâm đến lỗi, chúng ta có thể dùng <code>then(null, errorCallback)</code>. Và trong trường hợp này, <code>catch</code> cho chúng ta cú pháp đẹp hơn:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>).</span><span class=k>catch</span><span class=p>(</span><span class=nx>error</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
<span class=p>})</span>
</pre></div> <p>Việc gọi <code>catch</code> và <code>then(null, function)</code> hoàn toàn giống nhau, chúng ta có thể dùng loại nào mình cảm thấy thích. Những hàm được truyền vào <code>then</code> hoặc <code>catch</code> luôn luôn được đảm bảo rằng, chúng chỉ được thực thi khi nào promise được resolve hoặc reject mà thôi. Vì vậy, mọi việc hoạt động bất đồng bộ vẫn luôn được đảm bảo mà không cần lo về lỗi khi code được thực thi khi đang chờ code khác.</p> <p>Một lưu ý nữa là các đối tượng promise luôn đóng gói <code>state</code> và <code>result</code>, chúng ta không thể truy cập nó từ bên ngoài, mọi thao tác với promise đều cần phải sử dụng những API được cung cấp, <code>then</code>, <code>catch</code> là một trong số chúng.</p> <h2 id=co-che-trycatch-ngam>Cơ chế <code>try...catch</code> ngầm<a class=headerlink href=#co-che-trycatch-ngam title="Permanent link">&para;</a></h2> <p><code>then</code> và <code>catch</code> của promise có một cơ chế rất hay: Nếu có exception, cho dù promise không bị reject, callback vẫn ngầm hiểu rằng promise này trạng thái là rejected. Ví dụ:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span>
    <span class=nx>result</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>),</span>
    <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Error occured&#39;</span><span class=p>)</span>
<span class=p>)</span>
<span class=c1>// Error occured</span>
</pre></div> <p>Nó hoạt động hoàn toàn giống với:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>());</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span>
    <span class=nx>result</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>),</span>
    <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Error occured&#39;</span><span class=p>)</span>
<span class=p>)</span>
</pre></div> <h2 id=timing>Timing<a class=headerlink href=#timing title="Permanent link">&para;</a></h2> <p>Để không gây trở ngại cũng như khó khăn cho lập trình viên, các hàm truyền qua <code>then</code> hay <code>catch</code> không bao giờ được gọi đồng bộ. Chúng cũng hoạt động hoàn toàn bất đồng bộ, sẽ được thực thi sau khi toàn bộ code đồng bộ điược thư thi hết, ngay cả trong trường hợp promise được resolve ngay lập tức.</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;done&#39;</span><span class=p>)).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;asynchronous&#39;</span><span class=p>));</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;synchronous&#39;</span><span class=p>);</span>
<span class=c1>// Kết quả in ra sẽ là</span>
<span class=c1>// synchronous</span>
<span class=c1>// asynchronous</span>
</pre></div> <p>Về mặt kỹ thuật, những hàm được truyền vào <code>then</code> hay <code>catch</code> sẽ được đưa vào một hàng đợi. Điều này giúp chúng sẽ được thực thi sau, JavaScript engine của trình duyệt sẽ bắt đầu làm việc với hàng đợi này sau khi các code đã được thực thi xong. Và tất nhiên, các hàm trong hàng đợi sẽ được lấy ra khi promise của chúng đã được resolve hoặc reject.</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>wait</span> <span class=o>=</span> <span class=nx>ms</span> <span class=p>=&gt;</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>ms</span><span class=p>));</span>
<span class=nx>wait</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>));</span>
<span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>())</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
<span class=c1>// Kết quả sẽ là</span>
<span class=c1>// 1</span>
<span class=c1>// 2</span>
<span class=c1>// 3</span>
</pre></div> <p>Và promise cho chúng ta rất nhiều lợi ích so với cách sử dụng callback truyền thống ở trên:</p> <ul> <li>Callback truyền vào <code>then</code>, <code>catch</code> sẽ luôn được đảm bảo là không được thực thi khi mà các code JavaScript tiếp theo vẫn chưa hoàn thành. Trong phần lớn các trường hợp thì điều này không có nhiều ý nghĩa, tuy nhiên, nó vẫn cần thiết trong một vài trường hợp đặc biệt mà thứ tự code được thực thi sẽ cho kết quả khác nhau.</li> <li> <p>Các callback được truyền vào <code>then</code> và <code>catch</code> luôn được gọi, kể cả trường hợp nó được thêm vào sau khi promise được settle, và sau cả một vài code đồng bộ khác. Ví dụ:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=o>=&amp;</span><span class=nx>gt</span><span class=p>;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>2</span><span class=p>));</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
<span class=nx>x</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
<span class=c1>// 2</span>
</pre></div> </li> <li> <p>Hoạt động của <code>then</code> và <code>catch</code> cũng là bất đồng bộ, và kết quả trả về sau khi gọi hai hàm này cũng là một promise, điều đó cho phép chúng ta có thể gọi <code>then</code> liên tiếp để thực hiện nhiều công việc bất đồng bộ khác nhau.</p> </li> </ul> <h1 id=promise-chain>Promise chain<a class=headerlink href=#promise-chain title="Permanent link">&para;</a></h1> <p>Một nhu cầu rất chính đáng của chúng ta là cần phải thực thi hai hoặc nhiều hơn các hoạt động bất đồng bộ, theo thứ tự lần lượt từng thứ kết thúc một. Trong nhiều trường hợp, chúng ta còn phải sử dụng kết quả của hành động trước để có thể tiến hành các hoạt động tiếp theo.</p> <p>Promise có thể giúp chúng ta trong việc này.</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise1</span> <span class=o>=</span> <span class=nx>doSomething</span><span class=p>();</span>
<span class=kr>const</span> <span class=nx>promise2</span> <span class=o>=</span> <span class=nx>promise1</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>successCallback</span><span class=p>,</span> <span class=nx>failureCallback</span><span class=p>);</span>
</pre></div> <p>hoặc viết ngắn gọn hơn:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise2</span> <span class=o>=</span> <span class=nx>doSomething</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>successCallback</span><span class=p>,</span> <span class=nx>failureCallback</span><span class=p>);</span>
</pre></div> <p>Như đã nói ở trên, <code>then</code> sẽ trả về một promise, và promise này không chỉ là <code>doSomething</code> đã hoàn thành mà cả <code>successCallback</code> cũng đã hoàn thành (có thể là <code>failureCallback</code> trong trường hợp lỗi). Nhờ đó, chúng ta có thể tiếp tục sử dụng promise này cho những hành động tiếp theo. Trong trường hợp đó, những callback được truyền cho <code>promise2</code> sẽ cũng se được đưa vào hàng đợi, và đương nhiên, chúng phải xếp hàng ở phía sau.</p> <h2 id=chain-on-gian-voi-gia-tri-uoc-tra-ve>Chain đơn giản với giá trị được trả về<a class=headerlink href=#chain-on-gian-voi-gia-tri-uoc-tra-ve title="Permanent link">&para;</a></h2> <p>Nói đơn giản, sau mỗi bước, một promise sẽ được trả về, và nó đại diện cho kết quả của bước đó. Cách làm này giúp chúng ta không phải truyền callback, mà sử dụng kết quả của promise để tiến hành các hoạt động tiếp theo. Lưu ý rằng, nếu muốn sử dụng kết quả của bước trước ở bước tiếp theo, chúng ta cần <code>return</code> kết quả đó. Để dễ hiểu hơn, hãy xem xét một ví dụ sau:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>)).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span>  <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
<span class=p>})</span>
<span class=c1>// Kết quả sẽ là</span>
<span class=c1>// 1</span>
<span class=c1>// 2</span>
<span class=c1>// 4</span>
<span class=c1>// 8</span>
</pre></div> <p>Hơi ngoài lề một chút, nhưng chúng ta có thể sử dụng nhiều <code>then</code> với cùng một promise mà không chain. Điều này là hoàn toàn hợp lệ, về mặt kỹ thuật. Nhưng khác với chain, tất cả <code>then</code> của cùng một promise sẽ có cùng một kết quả. Trong thực tế thì việc này không được nhiều người sử dụng, mà chain mới là thứ chúng ta cần.</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
<span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>})</span>
<span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>})</span>
<span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
<span class=p>})</span>
<span class=nx>promise</span><span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
<span class=p>})</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
<span class=c1>// 1</span>
<span class=c1>// 1</span>
<span class=c1>// 1</span>
</pre></div> <h2 id=return-mot-promise>Return một promise<a class=headerlink href=#return-mot-promise title="Permanent link">&para;</a></h2> <p>Trong ví dụ trên, chúng ta chỉ đơn giản là return một giá trị và giá trị đó được sử dụng trong chain. Nhưng chúng ta hoàn toàn có thể return một promise khác, trong trường hợp chúng ta muốn thêm hoạt động bất đồng bộ khác.</p> <p>Nếu promise được return, callback được truyền vào trong <code>then</code> sẽ không được thực hiện ngay, mà nó sẽ phải chờ promise đó được resolve hoặc reject thì mới được thực thi. Khi đó, <code>result</code> của promise sẽ được sử dụng.</p> <p>Quay lại với ví dụ load script của chúng ta, với mỗi hoạt động load script là một promise, và vì mỗi script lại được load bất đồng bộ nên thông thường suy nghĩ của chúng ta sẽ là thế này:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script1.js&#39;</span><span class=p>).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
      <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script2.js&#39;</span><span class=p>).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
            <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script3.js&#39;</span><span class=p>).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
                  <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script4.js&#39;</span><span class=p>).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
                      <span class=c1>// Code sau khi tất cả các hoạt động bất đồng</span>
                      <span class=c1>// bộ hoàn thành.</span>
                  <span class=p>})</span>
              <span class=p>})</span>
        <span class=p>})</span>
  <span class=p>})</span>
</pre></div> <p>Về cơ bản thì lại là một kim tự tháp khác thôi mà, đây là trường hợp callback không <code>return</code> bất cứ một kết quả gì. Nhưng với promise, thì chúng ta không cần phải làm như vậy. JavaScript đã giải quyết vấn đề này giúp chúng ta rồi. Khi <code>then</code> có thể trả về một promise, và khi nó trả về một promise thì promise đó phải hoàn thành thì mới tới bước tiếp theo, nên chúng ta có thể code trông rất đẹp như sau:</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script1.js&#39;</span><span class=p>)</span>
  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script2.js&#39;</span><span class=p>))</span>
  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script3.js&#39;</span><span class=p>))</span>
  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;script4.js&#39;</span><span class=p>))</span>
  <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
      <span class=c1>// Code sau khi tất cả các hoạt động bất đồng</span>
      <span class=c1>// bộ hoàn thành.</span>
  <span class=p>})</span>
</pre></div> <p>Sử dụng promise giúp chúng ta xây dựng được chuỗi các hoạt động bất đồng bộ một cách rất dễ dàng. Ví dụ load script này có thể không thấy được kết quả ngay nên sẽ khó hình dung. Để rõ hơn, chúng ta có thể xem ví dụ sau:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>),</span> <span class=mi>1000</span><span class=p>));</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>),</span> <span class=mi>1000</span><span class=p>));</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=nx>result</span> <span class=o>*</span> <span class=mi>2</span><span class=p>),</span> <span class=mi>1000</span><span class=p>))</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
<span class=p>})</span>
</pre></div> <p>Ví dụ này có thể kiểm chứng ngay trong console của trình duyệt. Khi chạy, sau mỗi giây nó sẽ in ra một số, lần lượt sẽ là</p> <div class=codehilite><pre><span></span>1
2
4
8
</pre></div> <p>Flow ở đây rất dễ hiểu:</p> <ul> <li>Khi promise đầu tiên được resolve sau 1 giây, nó trả về kết quả và được callback trong <code>then</code> sử dụng.</li> <li>Callback này in ra kết quả và trả về một promise mới.</li> <li>Vì promise mới này cũng cần 1 giây để hoàn thành, nên callback trong <code>then</code> tiếp theo chưa được thực thi ngay.</li> <li>Nó đợi đến khi promise được resolve mới bắt đầu thực thi, lúc nào nó in ra kết quả <code>2</code> và trả về promise mới.</li> <li>Quá trình cứ tiếp tục như vậy cho đến khi hết các callback.</li> </ul> <p>Đây là cách hoạt động của promise chain, nó cho chúng ta code chuỗi các hoạt động bất đồng bộ một cách dễ dàng mà không phải sử dụng code kiểu lồng nhau, nguy cơ rất lớn dẫn đến callback hell. Có thể thấy đây chính là điểm mấu chốt của promise chain. Chúng ta cứ tạm hiểu rằng, <code>return</code> một giá trị xác định là một biến thể của hình thức này, khi đó JavaScript sẽ "ngầm" tạo ra một promise được resolve ngay với giá trị đó.</p> <h2 id=xu-ly-khi-gap-loi_1>Xử lý khi gặp lỗi<a class=headerlink href=#xu-ly-khi-gap-loi_1 title="Permanent link">&para;</a></h2> <p>Trong những ví dụ ở trên, chúng ta mới chỉ quan tâm đến việc các hoạt động bất đồng bộ kết thúc thành công. Tuy nhiên, không thể đảm bảo rằng, tất cả chúng sẽ luôn thành công như vậy. Trong trường hợp lỗi, tất nhiên là promise sẽ bị reject thay vì resolve.</p> <p>Và một nhu cầu tất yếu (dù không thường xuyên) là cần phải giải quyết hậu quả khi có lỗi xảy ra. Promise chain có một cơ chế tuyệt vời giúp chúng ta làm việc đó.</p> <div class=codehilite><pre><span></span><span class=nx>doSomething</span><span class=p>()</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=nx>doSomethingEles</span><span class=p>())</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>newResult</span> <span class=p>=&gt;</span> <span class=nx>doOtherThing</span><span class=p>())</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>finalResult</span> <span class=p>=&gt;</span> <span class=p>{</span>
      <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`I got the final result: </span><span class=si>${</span><span class=nx>finalResult</span><span class=si>}</span><span class=sb>`</span><span class=p>)</span>
    <span class=p>})</span>
    <span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>failureCallback</span><span class=p>)</span>
</pre></div> <p>Promise chain có một cơ chế rất hay, khi một promise bị reject, ngay lập tức, nó sẽ thực thi code xử lý gần nhất trong chuỗi. Cách làm này tương tự như cơ chế <code>try...catch</code> thông thường.</p> <div class=codehilite><pre><span></span><span class=k>try</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>syncDoSomething</span><span class=p>();</span>
    <span class=kr>const</span> <span class=nx>newResult</span> <span class=o>=</span> <span class=nx>syncDoSomethingElse</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>finalResult</span> <span class=o>=</span> <span class=nx>syncDoOtherThing</span><span class=p>(</span><span class=nx>newResult</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`I got the final result: </span><span class=si>${</span><span class=nx>finalResult</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
<span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>failureCallback</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Giờ hãy nhìn lại một chút ví dụ về load script của chúng ta, bạn có thể nhận ra rằng, trong cách làm callback truyền thống, chúng ta phải gọi <code>failureCallback</code> tới ba lần, trong khi cơ chế promise chain cho phép chúng ta chỉ cần gọi 1 lần là đủ.</p> <div class=codehilite><pre><span></span><span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>)</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;wrong-script-path.js&#39;</span><span class=p>))</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js&#39;</span><span class=p>))</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;All scripts loaded&#39;</span><span class=p>))</span>
    <span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>error</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>error</span><span class=p>))</span>
<span class=c1>// Kết quả sẽ là</span>
<span class=c1>// Error: script not loaded</span>
<span class=c1>//     at HTMLScriptElement.script...</span>
</pre></div> <p>Ở phần trước, chúng ta biết rằng, promise có một cơ chế <code>try...catch</code> ngầm. Nhưng đó là cơ chế đối với executor, vậy với các callback trong <code>then</code> thì sao?</p> <p>Thật tuyệt vời là cơ chế đó cũng tồn tại trong promise chain. Khi một callback nào đó có exception, nó cũng ngay lập tức coi đó là reject một promise và nhảy đến <code>catch</code> gần nhất.</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;ok&#39;</span><span class=p>))</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
    <span class=p>})</span>
    <span class=p>.</span><span class=k>catch</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Error occured&#39;</span><span class=p>))</span>
</pre></div> <p>Lưu ý rằng, <code>catch</code> ở đây vẫn là cách viết ngắn gọn của <code>then(null, function)</code>. Chúng ta hoàn toàn có thể dùng cú pháp đầy đủ cũng không vấn đề gì:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;ok&#39;</span><span class=p>))</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>result</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
    <span class=p>})</span>
    <span class=p>.</span><span class=nx>then</span><span class=p>(</span>
        <span class=nx>result</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>),</span>
        <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Error occured&#39;</span><span class=p>)</span>
    <span class=p>)</span>
</pre></div> <p>Một tác dụng phụ không mong muốn của cơ chế này là bất cứ exception nào (kể cả lỗi cú pháp) cũng bị coi là reject và nhảy đến catch gần nhất. Do đó, trong quá trình debug, đây có thể là một trở ngại rất lớn.</p> <h2 id=chain-tiep-theo-catch>Chain tiếp theo <code>catch</code><a class=headerlink href=#chain-tiep-theo-catch title="Permanent link">&para;</a></h2> <p>Chúng ta có thể dùng <code>catch</code> ở bất cứ đâu, không nhất thiết là ở cuối cùng. Đơn giản là <code>catch</code> cũng trả về một promise nên nó hoàn toàn có thể tiếp tục chain được. Chúng ta có thể dùng cách này để thực hiện một số hành động cần phải chạy trong cả trường hợp thành công và lỗi.</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Init&#39;</span><span class=p>);</span>
    <span class=nx>resolve</span><span class=p>();</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do this&#39;</span><span class=p>);</span>
<span class=p>}).</span><span class=k>catch</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do that&#39;</span><span class=p>);</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do this, no matter when happened&#39;</span><span class=p>)</span>
<span class=p>})</span>
<span class=c1>// Kết quả sẽ là</span>
<span class=c1>// Init</span>
<span class=c1>// Do that</span>
<span class=c1>// Do this, no matter what happened</span>
</pre></div> <p>Lưu ý rằng, <code>Do this</code> không được in ra bởi vì có exeption xảy ra, và nó coi như một promise bị reject. Hơn nữa, trong trường hợp trên, nếu <code>catch</code> không được thực thi (nếu không có lỗi nào xảy ra) thì <code>then</code> sau nó vẫn được thực thi như thường:</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Init&#39;</span><span class=p>);</span>
    <span class=nx>resolve</span><span class=p>();</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do this&#39;</span><span class=p>);</span>
<span class=p>}).</span><span class=k>catch</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do that&#39;</span><span class=p>);</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do this, no matter when happened&#39;</span><span class=p>)</span>
<span class=p>})</span>
<span class=c1>// Kết quả sẽ là</span>
<span class=c1>// Init</span>
<span class=c1>// Do this</span>
<span class=c1>// Do this, no matter what happened</span>
</pre></div> <p>Như vậy, chúng ta có thể đặt <code>catch</code> ở bất cứ đâu mà chúng ta cần để xử lý lỗi. Thậm chí chúng ta có thể sử dụng kết hợp nhiều <code>then</code> và <code>catch</code> để xử lý những lỗi khác nhau ở những giai đoạn khác nhau. Và mỗi giai đoạn như vậy, nếu là lỗi không xử lý được có thể throw lỗi đó để nhảy đến bước tiếp theo. Trong một chain nếu có nhiều <code>catch</code> thì khi có lỗi xảy ra, JavaScript engine sẽ thực thi code ở <code>catch</code> gần nhất.</p> <div class=codehilite><pre><span></span><span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Init&#39;</span><span class=p>);</span>
    <span class=nx>resolve</span><span class=p>();</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
<span class=p>}).</span><span class=k>catch</span><span class=p>((</span><span class=nx>error</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>error</span> <span class=k>instanceof</span> <span class=nx>EvalError</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Do this&#39;</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
        <span class=k>throw</span> <span class=nx>error</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}).</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;This will run only if error is handled&#39;</span><span class=p>)</span>
<span class=p>}).</span><span class=k>catch</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;unhandled error here&#39;</span><span class=p>)</span>
<span class=p>})</span>
<span class=c1>// Kết quả</span>
<span class=c1>// Init</span>
<span class=c1>// Unhandled error here</span>
</pre></div> <h1 id=promise-api>Promise API<a class=headerlink href=#promise-api title="Permanent link">&para;</a></h1> <p>Có 1 phương thức mà Promise cung cấp cho chúng ta, trong phần này, chúng ta sẽ tìm hiểu các phương thức đó.</p> <h2 id=resolve><code>resolve</code><a class=headerlink href=#resolve title="Permanent link">&para;</a></h2> <p>Phương thức cho chúng ta cách tắt để tạo một promise được resolve mới.</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</pre></div> <p>Code trên hoàn toàn tương đương với:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
</pre></div> <p>Phương thức này cho chúng ta một cách ngắn gọn để tạo promise mà giá trị của nó được xác định sẵn.</p> <h2 id=reject><code>reject</code><a class=headerlink href=#reject title="Permanent link">&para;</a></h2> <p>Tương tự như <code>resolve</code>, <code>reject</code> cũng là một phương thức cho chúng ta tạo ra một promise bị reject một cách nhanh chóng:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>());</span>
</pre></div> <p>Code trên hoàn toàn tương đương với:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>()));</span>
</pre></div> <p>Tuy nhiên, khác với <code>Promise.resolve</code>, phương thức này ít được sử dụng trong thực tế.</p> <h2 id=all><code>all</code><a class=headerlink href=#all title="Permanent link">&para;</a></h2> <p>Đây là phương thức cho chúng ta cơ chế thực thi nhiều promise song song với nhau. Và <code>Promise.all</code> chỉ kết thúc và trả về kết quả khi tất cả các promise đã được "settle".</p> <div class=codehilite><pre><span></span>const promise = Promise.all(iterable);
</pre></div> <p>Tham số <code>iterable</code> thường là một array các promise (về mặt kỹ thuật, bất cứ đối tượng iterable nào cũng được). Và kết quả của phương thức này là một promise, promise này được resolve nếu tất cả các promise trong <code>iterable</code> được resolve, và <code>result</code> của nó sẽ là một array các <code>result</code> của từng promise.</p> <p>Ví dụ, đoạn code sau sẽ được thự thi và sau 3 giây, một promise mới được resolve với giá trị <code>[1, 2, 3]</code> sẽ được trả về:</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// [1, 2, 3]</span>
</pre></div> <p>Giá trị trả về trong <code>result</code> của <code>Promise.all</code> sẽ tương ứng với thứ tự của các promise trong <code>iterable</code>, dù thời gian thực thi của các promise đó có thể nhanh chậm khác nhau.</p> <p>Trong trường hợp có một promise nào đó bị reject, <code>Promise.all</code> sẽ ngay lập tức trả về một promise với lỗi đó.</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>()),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=k>catch</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// Error</span>
<span class=c1>//    at setTimeout (&lt;anonymous&gt;:3:62)</span>
</pre></div> <p>Trong đoạn code trên, promise thứ hai bị reject sau hai giây, do đó, kết quả trả về của <code>Promise.all</code> là một promise bị reject với đúng lỗi đó. Trong trường hợp có nhiều lỗi thì chỉ có lỗi đầu tiên được ghi nhận:</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Error 1&#39;</span><span class=p>)),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Error 2&#39;</span><span class=p>)),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=k>catch</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả</span>
<span class=c1>// Error: Error 2</span>
<span class=c1>//    at setTimeout (&lt;anonymous&gt;:3:62)</span>
</pre></div> <p>Tuy nhiên, cũng cần lưu ý rằng, các promise được chạy song song và dù một promise bị reject thì chúng ta cũng không có cách nào để dừng các promise khác lại được. Chúng vẫn sẽ tiếp tục chạy cho tới khi "settle" nhưng kết quả sẽ bị bỏ qua.</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;this will not stop&#39;</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>(</span><span class=s1>&#39;Error 2&#39;</span><span class=p>)),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=k>catch</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả</span>
<span class=c1>// Error: Error 2</span>
<span class=c1>//    at setTimeout (&lt;anonymous&gt;:3:62)</span>
<span class=c1>// this will not stop</span>
</pre></div> <p>Một điều vi diệu là <code>Promise.all</code> nhận một iterable thường là một array các promise. Nhưng thực ra chúng ta có thể dùng bất cứ giá trị nào, trong trường hợp một giá trị được truyền vào, nó sẽ tự động hiểu điều đó tương đương với <code>Promise.resolve(value)</code>.</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
    <span class=mi>2</span><span class=p>,</span>
    <span class=mi>3</span><span class=p>,</span>
<span class=p>]).</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả là:</span>
<span class=c1>// [1, 2, 3]</span>
</pre></div> <h2 id=race><code>race</code><a class=headerlink href=#race title="Permanent link">&para;</a></h2> <p><code>Promise.race</code> tương tự như <code>Promise.all</code>, cũng nhận một iterable các promise, nhưng thay vì đợi tất cả các promise kết thúc, nó chỉ đợi một promise được "settle" và trả kết quả về chính promise đó.</p> <p>Ví dụ:</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>race</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>()),</span> <span class=mi>2000</span><span class=p>)),</span>
<span class=p>]).</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả</span>
<span class=c1>// 3</span>
</pre></div> <p>Kể cả trong trường hợp lỗi thì nó vẫn trả về promise đầu tiên:</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>race</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>((</span><span class=nx>resolve</span><span class=p>,</span> <span class=nx>reject</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>()),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=k>catch</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// Error</span>
<span class=c1>//    at setTimeout (&lt;anonymous&gt;:4:62)</span>
</pre></div> <p>Và cũng tương tự như <code>Promise.all</code>, khi promise đầu tiên đã "settle", thì những promise khác cũng không được dừng lại, mà nó vẫn tiếp tục chạy cho đến khi đến thúc, tuy nhiên, kết quả của chúng sẽ bị bỏ qua:</p> <div class=codehilite><pre><span></span><span class=nb>Promise</span><span class=p>.</span><span class=nx>race</span><span class=p>([</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;this will not stop&#39;</span><span class=p>),</span> <span class=mi>3000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=mi>2000</span><span class=p>)),</span>
    <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)),</span>
<span class=p>]).</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 3</span>
<span class=c1>// this will not stop</span>
</pre></div> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Promise là một phương án giúp chúng ta code bất đồng bộ trong JavaScript tốt hơn. Nó cho phép chúng ta phòng tránh callback hell và đóng gói các hoạt động bất đồng bộ, giúp chúng ta có thể code tốt hơn, xử lý lỗi dễ hơn. Đặc biệt là promise chain cho chúng ta khả năng code một chuỗi các hoạt động bất đồng bộ nối tiếp nhau.</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#JavaScript</span> <span>#Promise</span> <span>#async</span> <span>#await</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2018/Jul/17/javascript-asyncawait.html> Newer Post </a> </span> <span class=older-link> <a href=/2018/May/20/we-should-use-eslint-in-project.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>