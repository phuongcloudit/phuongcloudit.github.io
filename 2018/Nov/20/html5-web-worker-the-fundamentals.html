<!DOCTYPE html><title>HTML5 web worker: the fundamentals - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Web worker (còn tên gọi khác là worker) là một phương thức đơn giản cho phép website chạy các script ngầm. Tiến trình của worker có thể được thực thi mà không có bất cứ tương tác nào với giao diện người dùng. Trong bài viết này, chúng ta sẽ …"> <meta name=keywords content="JavaScript, Fundamental, Web worker, multithread, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="HTML5 web worker: the fundamentals - manhhomienbienthuy's space"> <meta name=twitter:description content="Web worker (còn tên gọi khác là worker) là một phương thức đơn giản cho phép website chạy các script ngầm. Tiến trình của worker có thể được thực thi mà không có bất cứ tương tác nào với giao diện người dùng. Trong bài viết này, chúng ta sẽ …"> <meta name=twitter:image content=/https://i.imgur.com/1zRqA1K.jpg> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> HTML5 web worker: the fundamentals </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on November 20, 2018 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2018/Nov/20/html5-web-worker-the-fundamentals.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/1zRqA1K.jpg alt="HTML5 web worker: the fundamentals"> <p>Web worker (còn tên gọi khác là worker) là một phương thức đơn giản cho phép website chạy các script ngầm. Tiến trình của worker có thể được thực thi mà không có bất cứ tương tác nào với giao diện người dùng. Trong bài viết này, chúng ta sẽ tìm hiểu một số cách sử dụng cơ bản của web worker.</p> <h1 id=van-e-tinh-toan-song-song-cua-javascript>Vấn đề: Tính toán song song của JavaScript<a class=headerlink href=#van-e-tinh-toan-song-song-cua-javascript title="Permanent link">&para;</a></h1> <p>Có rất nhiều vấn đề với khiến một ứng dụng có thể gặp phải "tắc cổ chai", khiến cho một ứng dụng web cho tốt tới mức nào cũng rất khó tiếp cận người dùng do hiệu suất thấp. Những vấn đề này có thể đến từ phía server (xử lý nhiều, tối ưu kém) hoặc ngay ở JavaScript của phía client.</p> <p>Trong bài viết này, chúng ta sẽ tạm thời chỉ bàn về vấn đề của JavaScript, những vấn đề đó có thể bao gồm việc tương thích với các trình duyệt, hiệu suất của JavaScript engine. Rất may là những vấn đề này ngày nay hầu như không còn nữa do CPU đã mạnh hơn rất nhiều, đồng thời các trình duyệt hiện đại cũng nâng cao hiệu suất của JavaScript engine rất nhiều rồi. Thậm chí kể cả nỗi kinh hoàng đối với các developer là trình duyệt của Microsoft cũng đã chuyển mình.</p> <p>Chỉ còn một vấn đề duy nhất vẫn còn tồn tại của JavaScript là chính bản thân ngôn ngữ. JavaScript là một ngôn ngữ đơn luồng, có nghĩa là code JavaScript gần như không thể chạy song song.</p> <p>Hãy tưởng tượng rằng một website cần phải thực thi rất nhiều thứ trên client bằng JavaScript: Xử lý các event trên giao diện, truy vấn và xử lý các phản hồi từ API, thay đổi giao diện tuỳ theo thao tác của người dùng, v.v... Đây là những công việc hết sức phổ thông của một ứng dụng web. Thế nhưng, thật không may, những điều trên không thể được thực hiện đồng thời vì hạn chế của chính ngôn ngữ JavaScript. Việc thực thi script phải tuần tự trong một tiến trình duy nhất.</p> <p>Các developer thường sử dụng một số kỹ thuật để "giả lập" tính toán song song trong JavaScript như sử dụng <a href=https://www.w3schools.com/jsref/met_win_settimeout.asp><code>setTimeout</code></a>, <a href=https://www.w3schools.com/jsref/met_win_setinterval.asp><code>setInterval</code></a>, <a href=https://www.w3schools.com/xml/xml_http.asp><code>XMLHttpRequest</code></a> và <a href=https://www.w3schools.com/js/js_events.asp>event trigger</a>. Vâng, tất cả những thứ trên đều được chạy "bất đồng bộ" và trông "có vẻ như" việc thực thi code là song song. Thế nhưng "bất đồng bộ" không hoàn toàn là "song song", bởi vì các hoạt động bất đồng bộ chỉ được thực hiện sau khi code đồng bộ được thực thi xong.</p> <p>Rất may là HTML 5 đã cung cấp cho chúng ta một phương thức mới giúp cho việc tính toán song song dễ dàng hơn rất nhiều.</p> <h1 id=web-worker-thread-cho-javascript>Web worker: thread cho JavaScript<a class=headerlink href=#web-worker-thread-cho-javascript title="Permanent link">&para;</a></h1> <p>Web worker (còn được gọi ngắn là worker) cung cấp cho chúng ta một số API để sinh các tiểu trình để chạy ngầm. Web worker cho phép chúng ta có thể thực thi một số tác vụ như khởi tạo script chạy ngầm để thực hiện các thao tác nâng cao, nhưng không làm gián đoạn bất cứ thao tác nào trên UI cũng như các script khác ảnh hưởng đến trải nghiệm người dùng. Nó sẽ giúp các website tránh được tình trạng "unresponsive script" vẫn thỉnh thoảng xuất hiện khi JavaScript thực hiện tính toán quá lớn.</p> <p><img alt=unresponsive src=https://cdn-images-1.medium.com/max/1600/0*w2rEwv9mE9xVPhRy.png></p> <p>Worker với cơ chế hoạt động multithread cho phép chúng ta thực hiện tính toán song song. Nó là phương án tốt nhất để giữ UI hoạt động trong khi các tác vụ nặng vẫn được thực thi.</p> <p>Có nhiều phương thức cho phép chúng ta làm việc này như web worker, service worker, v.v... Trong bài viết này, chúng ta chỉ đề cập đến một loại duy nhất, đó là web worker (có thể gọi tắt là worker). Các loại worker khác, xin dành cho các bài viết sau.</p> <h1 id=su-dung-web-worker>Sử dụng web worker<a class=headerlink href=#su-dung-web-worker title="Permanent link">&para;</a></h1> <p>Web worker là một phương thức đơn giản cho phép chúng ta thực thi script ngầm bằng thread. Lưu ý rằng, web worker không tương tác trực tiếp với DOM mà việc tương tác phải thực hiện thông qua <code>postMessage</code>.</p> <p>Một worker là một object được tạo ra từ class <code>Worker</code> (hoặc <code>SharedWorker</code>), nó sẽ thực thi một file JavaScript. File JavaScript sẽ chứa toàn bộ code chạy trong thread của worker, thread được thực thi trong ngữ cảnh hoàn khác với ngữ cảnh hiện tại. Vì vậy, nếu sử dụng biến <code>window</code> để truy cập đến các biến, hằng của ngữ cảnh hiện tại từ worker sẽ gặp lỗi.</p> <p>Ngữ cảnh của worker được đặt trong object <code>DedicatedWorkerGlobalScope</code> (trong trường hợp sử dụng dedicated worker) hoặc <code>SharedWorkerGlobalScrope</code> (nếu sử dụng shared worker). Dedicated worker là worker chỉ tương tác từ một script duy nhất, nó chỉ có thể tương tác với script mà nó được sinh ra, trong khi shared worker có thể tương tác từ nhiều script khác nhau.</p> <p>Một worker có thể thực thi bất cứ code JavaScript nào (có một số ít ngoại lệ). Ví dụ, worker không thể tương tác với DOM, hoặc một số phương thức cũng như thuộc tính của <code>window</code> không thể truy cập được. Nhưng chúng ta có thể sử dụng một lượng lớn các cơ chế khác như Web socket, các cơ chế lưu trữ dữ liệu như IndexedDB, Data Store API (chỉ có ở Firefox).</p> <p>Dữ liệu được gửi và nhận giữa worker và thread chính của trình duyệt thông qua message. Cả hai phía đều gửi message thông qua phương thức <code>postMessage</code> và xử lý khi nhận message này thông qua event <code>onmessage</code>.</p> <p>Một worker có thể sinh ra một worker khác, miễn là các worker này đều có chung nguồn gốc với cha gốc của chúng. Ngoài ra, worker có thể sử dụng <code>XMLHttpRequest</code> để thực thi các tác vụ liên quan đến truy vấn mạng. Tuy nhiên, khi đó <code>responseXML</code> và <code>channel</code> của request luôn luôn trống.</p> <h2 id=dedicated-worker>Dedicated worker<a class=headerlink href=#dedicated-worker title="Permanent link">&para;</a></h2> <p>Dedicated worker (worker dành riêng), đúng như tên gọi của nó, là worker chỉ có tương tác bởi script đầu tiên đã sinh ra nó. Trong phần này, chúng ta sẽ tập trung tìm hiển về dedicated worker (tất nhiên là chỉ ở mức cơ bản).</p> <p>Chúng ta sẽ tìm hiểu dedicated worker thông qua một ví dụ như sau: Nhập vào hai số, các số này sẽ được gửi tới dedicated worker, thực hiện phép nhân chúng với nhau sau đó kết quả sẽ được gửi lại thread chính và hiển thị.</p> <p>Bạn có thể xem một demo của ví dụ này <a href=https://manhhomienbienthuy.github.io/web-worker-sample/dedicated/ >ở đây</a>.</p> <p>Ví dụ này khá cơ bản, và có vẻ không thực tế lắm (chỉ nhân thì không cần đến worker chạy multithread làm gì cả). Thế nhưng nó là một ví dụ tốt để chúng ta tìm hiểu worker, không quá phức tạp và cũng dễ code.</p> <h3 id=kiem-tra-worker-co-uoc-ho-tro-khong>Kiểm tra worker có được hỗ trợ không<a class=headerlink href=#kiem-tra-worker-co-uoc-ho-tro-khong title="Permanent link">&para;</a></h3> <p>Để dễ dàng hơn trong việc chạy thử trên website riêng, các bạn nên viết script thành các file riêng, và những code trong phần này nên để trong một file.</p> <div class=codehilite><pre><span></span><span class=k>if</span> <span class=p>(</span><span class=o>!!</span><span class=nb>window</span><span class=p>.</span><span class=nx>Worker</span><span class=p>)</span> <span class=p>{</span>
    <span class=p>...</span>
<span class=p>}</span>
</pre></div> <h3 id=sinh-mot-dedicated-worker>Sinh một dedicated worker<a class=headerlink href=#sinh-mot-dedicated-worker title="Permanent link">&para;</a></h3> <p>Tạo một worker mới, mọi việc chúng ta cần làm là gọi class <code>Worker</code> với URI chỉ vào file JavaScript để thực hiện tác dụng trong worker đó:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>myWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&quot;worker.js&quot;</span><span class=p>);</span>
</pre></div> <h3 id=gui-message-en-worker>Gửi message đến worker<a class=headerlink href=#gui-message-en-worker title="Permanent link">&para;</a></h3> <p>Mọi tương tác của worker đến thread chính đều thực hiện thông qua phương thức <code>postMessage</code> và event <code>onmessage</code>. Nếu muốn gửi dữ liệu đến worker, chúng ta phải thực hiện như sau:</p> <div class=codehilite><pre><span></span><span class=nx>first</span><span class=p>.</span><span class=nx>onchange</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>myWorker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>([</span><span class=nx>first</span><span class=p>.</span><span class=nx>value</span><span class=p>,</span><span class=nx>second</span><span class=p>.</span><span class=nx>value</span><span class=p>]);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Main (first.onchange): Message posted to worker&#39;</span><span class=p>);</span>
<span class=p>}</span>

<span class=nx>second</span><span class=p>.</span><span class=nx>onchange</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>myWorker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>([</span><span class=nx>first</span><span class=p>.</span><span class=nx>value</span><span class=p>,</span><span class=nx>second</span><span class=p>.</span><span class=nx>value</span><span class=p>]);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Main (second.onchange): Message posted to worker&#39;</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Ở đây chúng ta có hai thẻ <code>input</code> được đại diện bởi hai biến <code>first</code> và <code>second</code>. Khi giá trị của chúng thay đổi, phương thức <code>postMessage</code> sẽ được gọi để gửi những dữ liệu đó đến worker. Thực tế, chúng ta có thể gửi bất cứ dữ liệu gì trong message này.</p> <p>Trong worker, chúng ta sẽ xử lý những dữ liệu thu được thông qua event <code>onmessage</code>:</p> <div class=codehilite><pre><span></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Worker: Message received from main script&#39;</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>workerResult</span> <span class=o>=</span> <span class=s1>&#39;Result: &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Worker: Posting message back to main script&#39;</span><span class=p>);</span>
    <span class=nx>postMessage</span><span class=p>(</span><span class=nx>workerResult</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Event <code>onmessage</code> cho phép chúng ta thực thi code của worker bất cứ khi nào nhận được message. Trong ví dụ của chúng ta, chúng ta chỉ đơn giản là nhân hai số nhận được từ message và gửi kết quả trở lại thread chính.</p> <p>Trong thread chính, chúng ta cũng sử dụng event <code>onmessage</code> để xử lý những dữ liệu nhận được từ worker:</p> <div class=codehilite><pre><span></span><span class=nx>myWorker</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>result</span><span class=p>.</span><span class=nx>textContent</span> <span class=o>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Main (myWorker.onmessage): Message received from worker&#39;</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Trong trường hợp cụ thể của chúng ta, chúng ta chỉ đơn giản là lấy dữ liệu này ra và hiển thị kết quả cho người dùng. Khi đó, người dùng có thể nhìn thấy kết quả tính toán một cách nhanh chóng.</p> <p>Lưu ý rằng, <code>onmessage</code> và <code>postMessage</code> ở thread chính (dùng để sinh ra worker) cần phải được gọi kèm với worker tương ứng, nhưng ở trong worker thì không cần làm như vậy. Lý do rất đơn giản, thread chính có thể có nhiều worker, còn trong một worker thì đương nhiên chỉ có một thread của worker đó mà thôi.</p> <p>Một lưu ý nữa là message được gửi và nhận giữa worker và thread chính không sử dụng chung object. Có nghĩa là dữ liệu được gửi và nhận sẽ được "copy" chứ không phải cứ thế truyền đi luôn.</p> <h3 id=ngung-worker-ang-chay>Ngừng worker đang chạy<a class=headerlink href=#ngung-worker-ang-chay title="Permanent link">&para;</a></h3> <p>Nếu muốn ngừng ngay lập tức một worker đang chạy từ thread chính, chúng ta có thể sử dụng phương thức sau:</p> <div class=codehilite><pre><span></span><span class=nx>myWorker</span><span class=p>.</span><span class=nx>terminate</span><span class=p>();</span>
</pre></div> <p>Thread của worker sẽ ngay lập tức bị kill mà không cần đợi các tác vụ của nó được thực thi xong.</p> <p>Bên trong worker, nó cũng có thể tự kill mình bằng phương thức sau:</p> <div class=codehilite><pre><span></span><span class=nx>close</span><span class=p>();</span>
</pre></div> <h3 id=xu-ly-loi>Xử lý lỗi<a class=headerlink href=#xu-ly-loi title="Permanent link">&para;</a></h3> <p>Khi có lỗi xảy ra trong quá trình thực thi của worker, chúng ta có thể sử dụng event <code>onerror</code> để bắt lỗi và xử lý. Bằng cách đó, chúng ta sẽ bắt một event là error (thuộc class <code>ErrorEvent</code>).</p> <p>Event lỗi này không thể cancel (<code>cancelable = false</code>), nhưng worker có thể sử dụng <code>preventDefault</code>. Phương thức này sẽ ngăn cản việc error đó ảnh hưởng đến bên ngoài.</p> <p>Event error có các thuộc tính sau mà chúng ta nên để ý:</p> <ul> <li><code>message</code>: Đây là thông báo lỗi dễ hiểu cho người dùng.</li> <li><code>filename</code>: Tên file script đã gặp lỗi.</li> <li><code>lineno</code>: số dòng của script đã gặp lỗi.</li> </ul> <h3 id=sinh-ra-cac-worker-con>Sinh ra các worker con<a class=headerlink href=#sinh-ra-cac-worker-con title="Permanent link">&para;</a></h3> <p>Worker có thể sinh ra các worker khác muốn. Những worker con đó phải có chung nguồn gốc với cha của chúng. Ngoài ra, URI của script được thực thi bởi worker con (subworker) sẽ được coi là đường dẫn tương đối tính từ worker cha của nó chứ không phải tính từ website. Điều đó giúp cho các worker dễ dàng theo dõi các con của nó hơn.</p> <h3 id=import-cac-script-khac>Import các script khác<a class=headerlink href=#import-cac-script-khac title="Permanent link">&para;</a></h3> <p>Worker có thể sử dụng <code>importScript</code> để import các script khác. Nó có thể không có tham số (không import gì) hoặc các URI là các script cần import. Tất cả các <code>importScript</code> sau đều hợp lệ:</p> <div class=codehilite><pre><span></span><span class=nx>importScripts</span><span class=p>();</span>                         <span class=cm>/* không import gì */</span>
<span class=nx>importScripts</span><span class=p>(</span><span class=s1>&#39;foo.js&#39;</span><span class=p>);</span>                 <span class=cm>/* imports 1 script &quot;foo.js&quot; */</span>
<span class=nx>importScripts</span><span class=p>(</span><span class=s1>&#39;foo.js&#39;</span><span class=p>,</span> <span class=s1>&#39;bar.js&#39;</span><span class=p>);</span>       <span class=cm>/* imports 2 scripts */</span>
<span class=nx>importScripts</span><span class=p>(</span><span class=s1>&#39;//example.com/hello.js&#39;</span><span class=p>);</span> <span class=cm>/* You can import scripts từ bên ngoài */</span>
</pre></div> <p>Trình duyệt sẽ load các script trong tham số và thực thi chúng. Tất cả các biến, hàm, v.v... của các script đó đều có thể truy cập được từ worker. Nếu script không thể load được, thì một exception là <code>NETWORK_ERROR</code> sẽ được bắn ra, và các code tiếp theo nó sẽ bị dừng lại.</p> <p>Việc load các script được import này sẽ được thực hiện lần lượt, và thực hiện đồng bộ. Nghĩa là các script được load trước sẽ được thực thi trước, sau đó mới load tiếp các script khác. Nhờ vậy, các hàm, biến được định nghĩa ở script trước có thể được truy cập ở script sau.</p> <p>Lưu ý rằng, việc download các file từ URI có thể được thực hiện song song, nhưng việc thực thi code từ các file script đó chắc chắn sẽ là tuần tự. Hàm <code>importScript</code> sẽ chỉ return (tức là đã thực thi xong) nếu các script trong tham số của nó được thực thi xong.</p> <h2 id=shared-worker>Shared worker<a class=headerlink href=#shared-worker title="Permanent link">&para;</a></h2> <p>Shared worker là worker có thể truy cập từ nhiều script khác nhau, thậm chí có thể truy cập được từ cửa sổ khác, iframe hoặc các worker khác. Trong phần này, chúng ta sẽ tìm hiểu một vài điểm cơ bản của shared worker.</p> <p>Cũng như phần trước, chúng ta sẽ tìm hiểu thông qua một ví dụ tương tự như phần trước, sử dụng worker để thực hiện phép nhân, mở thông thêm một chút là sử dụng luôn worker đó để thực hiện phép bình thường (là phép nhân một số với chính nó).</p> <p>Demo của ví dụ này có thể được xem <a href=https://manhhomienbienthuy.github.io/web-worker-sample/shared/ >ở đây</a></p> <p>Lưu ý rằng, dù shared worker có thể truy cập từ nhiều script khác nhau, nhưng yêu cầu là những script này phải có chung nguồn gốc (cùng protocol, host, port).</p> <h3 id=sinh-mot-shared-worker>Sinh một shared worker<a class=headerlink href=#sinh-mot-shared-worker title="Permanent link">&para;</a></h3> <p>Sinh một shared worker mới cũng đơn giản như sinh một dedicated worker vậy, sự khác biệt duy nhất là ở class của chúng:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>myWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedWorker</span><span class=p>(</span><span class=s2>&quot;worker.js&quot;</span><span class=p>);</span>
</pre></div> <p>Một sự khác biệt rất lớn của shared worker đó là việc giao tiếp giữa worker và các script khác phải thông qua một object port - đây là cổng được mở để script có thể tương tác với worker. Không giống như dedicated worker, cổng này cũng được mở nhưng hoàn toàn trong suốt với lập trình viên.</p> <p>Việc kết nối thông qua port này có thể được thực hiện tự động thông qua event <code>onmessage</code> hoặc gọi <code>start</code> cho tường minh. Nếu gọi <code>start</code> thì việc này phải được thực hiện trước khi gửi và nhận message.</p> <h3 id=gui-nha-nhan-message-tu-shared-worker>Gửi nhà nhận message từ shared worker<a class=headerlink href=#gui-nha-nhan-message-tu-shared-worker title="Permanent link">&para;</a></h3> <p>Việc gửi message từ shared worker cũng tương tự như dedicated worker, nhưng phương thức <code>postMessage</code> phải được gọi thông qua object <code>port</code>.</p> <div class=codehilite><pre><span></span><span class=nx>squareNumber</span><span class=p>.</span><span class=nx>onchange</span> <span class=o>=</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>myWorker</span><span class=p>.</span><span class=nx>port</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>([</span><span class=nx>squareNumber</span><span class=p>.</span><span class=nx>value</span><span class=p>,</span> <span class=nx>squareNumber</span><span class=p>.</span><span class=nx>value</span><span class=p>]);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Message posted to worker&#39;</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Giờ đây, với shared worker, ở trong chính bản thân worker, việc xử lý kết nối sẽ phức tạp hơn một chút:</p> <div class=codehilite><pre><span></span><span class=nx>onconnect</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=kd>var</span> <span class=nx>port</span> <span class=o>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>ports</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>

    <span class=nx>port</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=kd>var</span> <span class=nx>workerResult</span> <span class=o>=</span> <span class=s1>&#39;Result: &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
        <span class=nx>port</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>workerResult</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Trước tiên, chúng ta gọi <code>onconnect</code> event để xử lý khi có kết nối đến <code>port</code> (event này sẽ được trigger khi thread cha của nó gọi <code>onmessage</code> hoặc <code>start</code>). Sau đó, chúng ta phải sử dụng thuộc tính <code>port</code> của event để xử lý đúng kết nối đến worker.</p> <p>Sau đó, việc tính toán và xử lý tương tự như ví dụ với dedicated server. Quay trở lại với script chính, chúng ta cũng cần thực hiện việc nhận message từ worker:</p> <div class=codehilite><pre><span></span><span class=nx>myWorker</span><span class=p>.</span><span class=nx>port</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=nx>result2</span><span class=p>.</span><span class=nx>textContent</span> <span class=o>=</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Message received from worker&#39;</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Lưu ý rằng, ở đây, chúng ta tạo worker thực hiện cùng một tác vụ (được định nghĩa trong <code>worker.js</code>), nếu không sử dụng shared worker, thì không thể làm được việc này. Bởi vì dedicated worker chỉ cho phép kết nối với script đầu tiên đã tạo ra nó, những script sau đó dù có sinh worker cũng không thể gửi và nhận message được.</p> <h2 id=inline-worker>Inline worker<a class=headerlink href=#inline-worker title="Permanent link">&para;</a></h2> <p>Có một số trường hợp, chúng ta muốn tạo ra worker một cách "động" mà không muốn viết script cho worker đó ra file riêng. Khi đó, chúng ta cần một phương thức nào đó để có thể cấp phát động một vùng nhớ để lưu trữ script đó.</p> <p>Rất may, một số thủ thuật với JavaScript có thể giúp chúng ta thực hiện việc đó khá dễ dàng. Lấy luôn ví dụ với worker thực hiện phép nhân của chúng ta, chúng ta có thể tạo ra inline worker như sau:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>blob</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Blob</span><span class=p>([</span>
    <span class=sb>`onmessage = (e) =&gt; {</span>
<span class=sb>        console.log(&#39;Worker: Message received from main script&#39;);</span>
<span class=sb>        const workerResult = &#39;Result: &#39; + (e.data[0] * e.data[1]);</span>
<span class=sb>        console.log(&#39;Worker: Posting message back to main script&#39;);</span>
<span class=sb>        postMessage(workerResult);</span>
<span class=sb>    }`</span>
<span class=p>]);</span>
<span class=kr>const</span> <span class=nx>blobURL</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>URL</span><span class=p>.</span><span class=nx>createObjectURL</span><span class=p>(</span><span class=nx>blob</span><span class=p>);</span>
<span class=kr>const</span> <span class=nx>myWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=nx>blobURL</span><span class=p>);</span>
</pre></div> <p>Demo của cách làm này, mời các bạn xem <a href=https://manhhomienbienthuy.github.io/web-worker-sample/inline/ >ở đây</a>.</p> <p>Mấu chốt vấn đề ở đây đến từ <code>Blob</code> và <code>BlobURL</code>, được tạo ra bởi <code>window.URL.createObjectURL</code>. Phương thức này sẽ tạo ra một URL để truy cập đến dữ liệu được lưu trong <code>DOM File</code> hoặc <code>Blob</code>:</p> <div class=codehilite><pre><span></span><span class=n>blob</span><span class=o>:</span><span class=n>http</span><span class=o>://</span><span class=n>localhost</span><span class=o>/</span><span class=n>b8fce994</span><span class=o>-</span><span class=mi>9</span><span class=n>a2e</span><span class=o>-</span><span class=mi>48</span><span class=n>ea</span><span class=o>-</span><span class=mi>9</span><span class=n>f51</span><span class=o>-</span><span class=n>c926960e8571</span>
</pre></div> <p>Blob URL là duy nhất và sẽ tồn tại theo thời gian của website (nó chỉ mất đi nếu <code>document</code> unload).</p> <h2 id=worker-scope>Worker scope<a class=headerlink href=#worker-scope title="Permanent link">&para;</a></h2> <p>Trong worker, ngữ cảnh của nó tương đối bị thu hẹp. Trong đó, <code>self</code> và <code>this</code> tham chiếu đến chính worker đó, và là các biến global trong toàn bộ code của worker. Do đó, code của worker như sau:</p> <div class=codehilite><pre><span></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>workerResult</span> <span class=o>=</span> <span class=s1>&#39;Result: &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=nx>postMessage</span><span class=p>(</span><span class=nx>workerResult</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>cũng tương đương với:</p> <div class=codehilite><pre><span></span><span class=nx>self</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>workerResult</span> <span class=o>=</span> <span class=s1>&#39;Result: &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=nx>self</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>workerResult</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>và tương đương luôn:</p> <div class=codehilite><pre><span></span><span class=k>this</span><span class=p>.</span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>workerResult</span> <span class=o>=</span> <span class=s1>&#39;Result: &#39;</span> <span class=o>+</span> <span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>*</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>workerResult</span><span class=p>);</span>
<span class=p>}</span>
</pre></div> <p>Ngoài ra, vì hoạt động của worker là multithread, nó chỉ có thể truy cập đến một phần nhỏ các biến cũng như hàm toàn cục của JavaScript như:</p> <ul> <li><code>navigator</code></li> <li><code>location</code> (read only)</li> <li><code>XMLHttpRequest</code></li> <li><code>setTimeout</code>, <code>clearTimeout</code></li> <li><code>setInterval</code>, <code>clearInterval</code></li> </ul> <p>Worker <strong>không thể</strong> truy cập được đến:</p> <ul> <li>DOM</li> <li><code>window</code></li> <li><code>document</code></li> <li><code>parent</code></li> </ul> <h1 id=khi-nao-thi-nen-su-dung-web-worker>Khi nào thì nên sử dụng web worker<a class=headerlink href=#khi-nao-thi-nen-su-dung-web-worker title="Permanent link">&para;</a></h1> <p>Web worker rất cool và cực kỳ hữu ích với các ứng dụng web. Dưới đây là một số tình huống chúng ta có thể sử dụng web worker trong ứng dụng web của mình:</p> <ul> <li>Tải trước dữ liệu nhưng không dùng ngay mà để sau này mới dùng đến.</li> <li>Các thao tác định dang văn bản real-time (ví dụ code highlight hay preview với các editor trên nền web).</li> <li>Kiểm tra chính tả, kiểm tra ngữ pháp của văn bản nhập vào.</li> <li>Xử lý, phân tích dữ liệu hình ảnh, âm thanh.</li> <li>Các thao tác truyền, nhận dữ liệu qua long polling.</li> <li>Xử lý một khối lượng dữ liệu JSON rất lớn.</li> <li>v.v...</li> </ul> <h1 id=mot-vai-van-e-khac>Một vài vấn đề khác<a class=headerlink href=#mot-vai-van-e-khac title="Permanent link">&para;</a></h1> <p>Trình duyệt Google Chrome có một số giới hạn liên quan đến bảo mật, nên worker không thể chạy được từ file tĩnh (load bằng <code>file:///</code>, tất nhiên là có thể thay đổi settings này). Một số trình duyệt dẫn xuất từ Chromium cũng gặp phải vấn đề này (ví dụ Opera).</p> <p>Ngoài ra, việc load script cho worker yêu cầu phải chung nguồn gốc với website hiện tại, do đó, không thể load script từ <code>data:</code> hoặc <code>javascript:</code>. Đồng thời trang web sử dụng HTTPS cũng không thể load script cho worker sử dụng HTTP.</p> <p>Worker thật sự sinh ra một thread trong bộ nhớ máy tính, nhiều người có thể lo lắng rằng nó sẽ gây ra các tác dụng phụ với hệ thống. Tuy nhiên, web worker được quản lý rất cẩn thận trong việc tương tác với các thread khác, nên thường nó rất khó gây ra các lỗi cho hệ thống. Nó không được truy cập DOM cũng như các object không thread-safe khác, do đó, rất khó để gặp vấn đề với worker.</p> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Worker thực sự là một giải pháp cho phép chúng ta thực hiện multithread với JavaScript rất hay. Hy vọng bài viết giúp ích cho các bạn trong công việc, trong các bài viết sau, chúng ta sẽ dành thời gian tìm hiểu các loại worker khác.</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#JavaScript</span> <span>#Fundamental</span> <span>#Web worker</span> <span>#multithread</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2018/Nov/25/markdown-editor-reviews.html> Newer Post </a> </span> <span class=older-link> <a href=/2018/Nov/09/personal-information-leaks.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>