<!DOCTYPE html><title>Javascript: async/await - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Trong bài viết trước, chúng ta đã tìm hiểu cách sử dụng Promise để code bất đồng bộ dễ dàng hơn. Trong bài viết này, chúng ta sẽ tìm hiểu thêm những cách nâng cao hơn nữa để code bất đồng bộ trong JavaScript. Đó chính là sử dụng async …"> <meta name=keywords content="JavaScript, Promise, async, await, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Javascript: async/await - manhhomienbienthuy's space"> <meta name=twitter:description content="Trong bài viết trước, chúng ta đã tìm hiểu cách sử dụng Promise để code bất đồng bộ dễ dàng hơn. Trong bài viết này, chúng ta sẽ tìm hiểu thêm những cách nâng cao hơn nữa để code bất đồng bộ trong JavaScript. Đó chính là sử dụng async …"> <meta name=twitter:image content=/https://i.imgur.com/UVKNyjm.png> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Javascript: async/await </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on July 17, 2018 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2018/Jul/17/javascript-asyncawait.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/UVKNyjm.png alt="Javascript: async/await"> <p>Trong <a href=../../../2018/Jun/20/javascript-promise.html>bài viết trước</a>, chúng ta đã tìm hiểu cách sử dụng Promise để code bất đồng bộ dễ dàng hơn. Trong bài viết này, chúng ta sẽ tìm hiểu thêm những cách nâng cao hơn nữa để code bất đồng bộ trong JavaScript. Đó chính là sử dụng <code>async</code> và <code>await</code>, những keyword mới được giới thiệu từ ECMAScript 2017 (ES8).</p> <p>Cách hoạt động của <code>async/await</code> dựa trên generator, vì vậy, để hiểu được <code>async/await</code>, chúng ta cần hiểu về generator trước đã.</p> <blockquote> <p>Bài viết tập trung chủ yếu vào code bất đồng bộ với <code>async/await</code> nên những gì trình bày về generator ở đây chỉ ở mức sơ khai. Nếu muốn tìm hiểu kỹ hơn, mời các bạn tìm đọc các bài viết chuyên sâu hơn về chủ đề này.</p> </blockquote> <h1 id=generator>Generator<a class=headerlink href=#generator title="Permanent link">&para;</a></h1> <p><a href=https://www.ecma-international.org/ecma-262/6.0/#sec-generator-function-definitions>Generator</a> của JavaScript được giới thiệu kể từ ECMAScript 2015 (ES6). Tôi đã từng làm việc với ngôn ngữ Python và thấy rằng, generator của JavaScript cũng có ý tưởng tương tự như <a href=../../../2016/Jan/05/python-iterator-generator.html>generator của Python</a>.</p> <p>Trong JavaScript, để định nghĩa một generator, chúng ta cần định nghĩa chúng là một <code>function*</code> (keyword <code>function</code> và tiếp theo là dấu sao <code>*</code>, có thể thêm dấu space tuỳ vào phong cách của mỗi người). Khi gặp định nghĩa này, chúng ta sẽ thu được một generator (thuộc lớp <code>GeneratorFunction</code>) thay vì một hàm thông thường. (Cú pháp có chặt chẽ hơn Python đôi chút).</p> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>generator</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=nx>i</span><span class=p>;</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Chúng ta cũng có thể sử dụng cú pháp generator expression để định nghĩa:</p> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>generator</span> <span class=o>=</span> <span class=kd>function</span><span class=o>*</span> <span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=nx>i</span><span class=p>;</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Một lưu ý nhỏ là lớp <code>GeneratorFunction</code> không phải đối tượng chúng ta có thể truy cập được nên không thể dùng nó để tạo ra một generator được mà phải dùng cú pháp như trên.</p> <p>Cách sử dụng generator rất đơn giản thôi:</p> <div class=codehilite><pre><span></span><span class=kd>var</span> <span class=nx>gen</span> <span class=o>=</span> <span class=nx>generator</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>gen</span><span class=p>.</span><span class=nx>next</span><span class=p>().</span><span class=nx>value</span><span class=p>);</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>gen</span><span class=p>.</span><span class=nx>next</span><span class=p>().</span><span class=nx>value</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 10</span>
<span class=c1>// 20</span>
</pre></div> <h2 id=cach-thuc-hoat-ong>Cách thức hoạt động<a class=headerlink href=#cach-thuc-hoat-ong title="Permanent link">&para;</a></h2> <p>Khi gọi một hàm generator, thì nội hàm đó sẽ không được thực thi ngay, mà một đối tượng <a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_generators>iterator</a> sẽ được trả về. Khi phương thức <code>next</code> của iterator đó được gọi (vòng lặp <code>for..of</code> cũng gọi đến phương thức này), nội dung của hàm generator mới được thực thi, và nó sẽ "tạm dừng" khi gặp lệnh <code>yield</code>. Những gì tiếp sau lệnh <code>yield</code> sẽ là giá trị được trả về của phương thức <code>next</code>.</p> <p>Phương thức <code>next</code> trả về kết quả là một đối tượng là giá trị được <code>yield</code> và một trạng thái biểu thị generator đã <code>yield</code> giá trị cuối cùng hay chưa (giá trị <code>done</code> là <code>true</code> hoặc <code>false</code>). Nếu chưa, chúng ta có thể tiếp tục gọi <code>next</code> và hàm generator đang bị tạm dừng sẽ tiếp tục chạy cho đến khi gặp <code>yield</code> tiếp theo (hoặc hàm kết thúc).</p> <p>Ngoài ra, generator có thể sử dụng <code>yield*</code> để <code>yield</code> một generator khác. Hàm generator cũng có thể dùng <code>return</code>. Nếu một giá trị được <code>return</code> thì nó cũng tương tự <code>yield</code> sẽ là giá trị trả về của <code>next</code>, đồng thời hàm sẽ kết thúc tại đó.</p> <p>Một generator đã kết thúc (<code>done</code>) thì dù chúng ta có tiếp tục gọi <code>next</code>, nó sẽ không thực thi thêm bất cứ một đoạn code nào của generator đó nữa. Ngoài ra, nếu có exception xảy ra, thì generator cũng bị kết thúc sớm (generator <code>done</code> nhưng giá trị sẽ là <code>undefined</code>).</p> <p>Bằng cách hoạt động như vậy, generator chỉ thực hiện tính toán và <code>yield</code> các giá trị khi cần thiết. Vì vậy, nó rất thích hợp để thực hiện những tính toán mất nhiều thời gian và bộ nhớ, ví dụ như một mảng vô hạn chẳng hạn.</p> <h2 id=mot-so-vi-du>Một số ví dụ<a class=headerlink href=#mot-so-vi-du title="Permanent link">&para;</a></h2> <h3 id=mot-generator-thong-thuong>Một generator thông thường<a class=headerlink href=#mot-generator-thong-thuong title="Permanent link">&para;</a></h3> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>let</span> <span class=nx>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span>
        <span class=k>yield</span> <span class=nx>index</span><span class=o>++</span><span class=p>;</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>bar</span> <span class=o>=</span> <span class=nx>foo</span><span class=p>();</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 0, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 1, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 2, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 3, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 4, done: false}</span>
</pre></div> <h3 id=generator-su-dung-expression>Generator sử dụng expression<a class=headerlink href=#generator-su-dung-expression title="Permanent link">&para;</a></h3> <div class=codehilite><pre><span></span><span class=kr>const</span> <span class=nx>foo</span> <span class=o>=</span> <span class=kd>function</span><span class=o>*</span> <span class=p>()</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=mi>10</span><span class=p>;</span>
    <span class=k>yield</span> <span class=mi>20</span><span class=p>;</span>
<span class=p>};</span>

<span class=kr>const</span> <span class=nx>bar</span> <span class=o>=</span> <span class=nx>foo</span><span class=p>();</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 10, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: 20, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: undefined, done: false}</span>
</pre></div> <h3 id=goi-generator-khac-voi-yield>Gọi generator khác với <code>yield*</code><a class=headerlink href=#goi-generator-khac-voi-yield title="Permanent link">&para;</a></h3> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>3</span><span class=p>;</span>
<span class=p>}</span>

<span class=kd>function</span><span class=o>*</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=nx>i</span><span class=p>;</span>
    <span class=k>yield</span><span class=o>*</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span>
    <span class=k>yield</span> <span class=nx>i</span> <span class=o>+</span> <span class=mi>10</span><span class=p>;</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>fooBar</span> <span class=o>=</span> <span class=nx>bar</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>

<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 10, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 11, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 12, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 13, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// {value: 20, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>fooBar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: undefined, done: true}</span>
</pre></div> <h3 id=truyen-tham-so-cho-generator>Truyền tham số cho generator<a class=headerlink href=#truyen-tham-so-cho-generator title="Permanent link">&para;</a></h3> <p>Phương thức <code>next</code> có thể nhận tham số để thay đổi trạng thái hiện tại của generator. Giá trị được truyền vào cho <code>next</code> được coi là kết quả được trả về của lệnh <code>yield</code> cuối cùng trước khi generator bị tạm dừng (bình thường lệnh này sẽ không trả về gì cả).</p> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>logGenerator</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=k>yield</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=k>yield</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=k>yield</span><span class=p>);</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>logger</span> <span class=o>=</span> <span class=nx>logGenerator</span><span class=p>();</span>

<span class=nx>logger</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span>
<span class=c1>// 0</span>
<span class=nx>logger</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=s1>&#39;pretzel&#39;</span><span class=p>);</span>
<span class=c1>// 1 pretzel</span>
<span class=nx>logger</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=s1>&#39;california&#39;</span><span class=p>);</span>
<span class=c1>// 2 california</span>
<span class=nx>logger</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=s1>&#39;mayonnaise&#39;</span><span class=p>);</span>
<span class=c1>// 3 mayonnaise</span>
</pre></div> <p>Trong ví dụ dưới, chúng ta có thể sử dụng <code>next(true)</code> để reset chuỗi lại từ đầu:</p> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=kd>let</span> <span class=nx>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=k>while</span> <span class=p>(</span><span class=kc>true</span><span class=p>)</span> <span class=p>{</span>
        <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=k>yield</span> <span class=nx>index</span><span class=o>++</span><span class=p>;</span>
        <span class=k>if</span> <span class=p>(</span><span class=nx>result</span><span class=p>)</span> <span class=p>{</span>
            <span class=nx>index</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>bar</span> <span class=o>=</span> <span class=nx>foo</span><span class=p>();</span>

<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: 0, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: 1, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=kc>true</span><span class=p>))</span>
<span class=c1>// {value: 0, done: false}</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>())</span>
<span class=c1>// {value: 1, done: false}</span>
</pre></div> <h3 id=goi-return-trong-generator>Gọi <code>return</code> trong generator<a class=headerlink href=#goi-return-trong-generator title="Permanent link">&para;</a></h3> <div class=codehilite><pre><span></span><span class=kd>function</span><span class=o>*</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>yield</span> <span class=s1>&#39;yield&#39;</span><span class=p>;</span>
    <span class=k>return</span> <span class=s1>&#39;return&#39;</span><span class=p>;</span>
    <span class=k>yield</span> <span class=s1>&#39;unreachable&#39;</span><span class=p>;</span>
<span class=p>}</span>

<span class=kr>const</span> <span class=nx>bar</span> <span class=o>=</span> <span class=nx>foo</span><span class=p>()</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// { value: &quot;yield&quot;, done: false }</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// { value: &quot;return&quot;, done: true }</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>bar</span><span class=p>.</span><span class=nx>next</span><span class=p>());</span>
<span class=c1>// { value: undefined, done: true }</span>
</pre></div> <h1 id=su-dung-generator-e-code-bat-ong-bo>Sử dụng generator để code bất đồng bộ<a class=headerlink href=#su-dung-generator-e-code-bat-ong-bo title="Permanent link">&para;</a></h1> <p>Generator có một tính chất rất hay đó là hàm generator có thể được thực thi, rồi tạm dừng, sau đó tiếp tục thực thi mà trạng thái của nó sẽ được lưu lại. Tất cả mọi biến, hằng, v.v... sẽ được giữ nguyên giá trị khi hàm được thực thi trở lại sau khi tạm dừng.</p> <p>Vì vậy, generator có thể kết hợp với Promise (vốn là một công cụ tuyệt vời) để giúp chúng ta code bất đồng bộ dễ dàng hơn nữa. Promise đã giúp chúng ta rất nhiều nhưng code bất đồng bộ vẫn còn quá khó đọc và hiểu so với code đồng bộ. Việc xử lý khi gặp lỗi vẫn còn sử dụng rất nhiều đến cơ chế callback mà không thể dùng những cú pháp tiện lợi của chính JavaScript như <code>try..catch</code>.</p> <p>Chúng ta có thể kết hợp generator với Promise theo cách sau: <code>yield</code> một promise khi nào chúng ta muốn code tạm dừng (vì hoạt động bất đồng bộ), và trong callback của promise đó sẽ gọi tiếp <code>next</code> của generator để hàm tiếp tục chạy. Dưới đây là một ví dụ:</p> <div class=codehilite><pre><span></span><span class=kd>let</span> <span class=nx>foo</span><span class=p>;</span>
<span class=kd>function</span><span class=o>*</span> <span class=nx>bar</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;before async&#39;</span><span class=p>);</span>
    <span class=k>yield</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>1000</span><span class=p>)).</span><span class=nx>then</span><span class=p>(</span><span class=nx>x</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
        <span class=nx>foo</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span>
    <span class=p>})</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;after async&#39;</span><span class=p>);</span>
<span class=p>}</span>
<span class=nx>foo</span> <span class=o>=</span> <span class=nx>bar</span><span class=p>();</span>
<span class=nx>foo</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span>
</pre></div> <p>Trong code cũng không lấy gì làm đẹp lắm. Nhưng nó đã hoạt động đúng: sau khi in ra dòng <code>before async</code> thì 1 giấy sau nó mới in ra kết quả của promise và tiếp theo là dòng <code>after async</code>. Bằng cách kết hợp generator với Promise như thế này, chúng ta có thể tạm dừng một hàm để chờ các hoạt động bất đồng bộ được thực thi và sau đó lại tiếp tục hàm.</p> <p>Cách làm này cho chúng ta kết quả hay hơn khá nhiều so với chỉ sử dụng Promise thông thường, khi mà code bất đồng bộ sẽ luôn bị thực thi sau code đồng bộ.</p> <p>Tuy nhiên, code này không phải là một dạng tổng quát, chúng ta sẽ phải biến hoá nó cho từng bài toán cụ thể. Ngoài ra, generator cũng giúp chúng ta xử lý lỗi bằng cú pháp <code>try..catch</code> truyền thống của JavaScript.</p> <p>Chúng ta có thể xây dựng một hàm cho phép tạm dừng code với generator và Promise tương đối tổng quát như sau:</p> <div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>async</span><span class=p>(</span><span class=nx>gen</span><span class=p>,</span> <span class=nx>context</span><span class=o>=</span><span class=kc>undefined</span><span class=p>)</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>generator</span> <span class=o>=</span> <span class=k>typeof</span> <span class=nx>gen</span> <span class=o>===</span> <span class=s1>&#39;function&#39;</span> <span class=o>?</span> <span class=nx>gen</span><span class=p>()</span> <span class=o>:</span> <span class=nx>gen</span><span class=p>;</span>
    <span class=kr>const</span> <span class=p>{</span><span class=nx>value</span><span class=o>:</span> <span class=nx>promise</span><span class=p>}</span> <span class=o>=</span> <span class=nx>generator</span><span class=p>.</span><span class=nx>next</span><span class=p>(</span><span class=nx>context</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=k>typeof</span> <span class=nx>promise</span> <span class=o>!==</span> <span class=s1>&#39;undefined&#39;</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>promise</span>
            <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>resolved</span> <span class=p>=&gt;</span> <span class=nx>async</span><span class=p>(</span><span class=nx>generator</span><span class=p>,</span> <span class=nx>resolved</span><span class=p>))</span>
            <span class=p>.</span><span class=k>catch</span><span class=p>(</span><span class=nx>error</span> <span class=p>=&gt;</span> <span class=nx>generator</span><span class=p>.</span><span class=k>throw</span><span class=p>(</span><span class=nx>error</span><span class=p>));</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Sử dụng hàm này, chúng ta có thể tạm dừng một hàm bằng cách <code>yield</code> một Promise, chờ nó kết thúc và nhận kết quả về:</p> <div class=codehilite><pre><span></span><span class=nx>async</span><span class=p>(</span><span class=kd>function</span><span class=o>*</span> <span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;before async&#39;</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(</span>
        <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=s1>&#39;async&#39;</span><span class=p>),</span>
        <span class=mi>1000</span>
    <span class=p>));</span>
    <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=k>yield</span> <span class=nx>promise</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;after async&#39;</span><span class=p>);</span>
<span class=p>})</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// before async</span>
<span class=c1>// (Tạm dừng 1 giấy)</span>
<span class=c1>// async</span>
<span class=c1>// after async</span>
</pre></div> <p>Bằng cách sử dụng đệ quy, chúng ta có thể tạm dừng một hàm bao nhiêu lần cũng được:</p> <div class=codehilite><pre><span></span><span class=nx>async</span><span class=p>(</span><span class=kd>function</span><span class=o>*</span> <span class=p>()</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>promise1</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>1000</span><span class=p>));</span>
    <span class=kr>const</span> <span class=nx>promise2</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=mi>1000</span><span class=p>));</span>
    <span class=kr>const</span> <span class=nx>promise3</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=mi>2000</span><span class=p>));</span>

    <span class=kr>const</span> <span class=nx>result1</span> <span class=o>=</span> <span class=k>yield</span> <span class=nx>promise1</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result1</span><span class=p>);</span>
    <span class=kr>const</span> <span class=p>[</span><span class=nx>result2</span><span class=p>,</span> <span class=nx>result3</span><span class=p>]</span> <span class=o>=</span> <span class=k>yield</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>all</span><span class=p>([</span><span class=nx>promise2</span><span class=p>,</span> <span class=nx>promise3</span><span class=p>]);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>result2</span><span class=p>,</span> <span class=nx>result3</span><span class=p>);</span>
<span class=p>})</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1 (hiện ra sau 1 giây)</span>
<span class=c1>// 2 3 (hiện ra sau 2 giây)</span>
</pre></div> <p>Vậy là chúng ta đã có một cách tương đối tổng quát dùng để code bất đồng bộ rất dễ dàng. Tuy nhiên, mức độ tổng quát như trên chưa thể đảm bảo được. Nó sẽ chạy tốt cho các trường hợp thông thường, nhưng không rõ là một số trường hợp "không thông thường" thì sẽ thế nào.</p> <p>Rất may cho chúng ta, những người làm đặc tả cho ngôn ngữ, cụ thể là tổ chức <a href=https://www.ecma-international.org/ >Ecma International</a> với đặc tả ECMAScript đã thiết kế phần này giúp chúng ta. Tuy nó ra đời hơi muộn, nhưng muộn còn hơn là không có, những tính năng mới của JavaScript sẽ giúp chúng ta code bất đồng bộ dễ dàng hơn bao giờ hết. Đó chính là nội dung mà chúng ta sẽ tìm hiểu ngay sau đây.</p> <h1 id=asyncawait>Async/await<a class=headerlink href=#asyncawait title="Permanent link">&para;</a></h1> <p>Async/await được thêm vào từ đặc tả <a href=https://www.ecma-international.org/ecma-262/8.0/#sec-async-function-definitions>ECMAScript 2017</a> (ES 8), nên hiện nay chưa được hỗ trợ bởi tất cả các trình duyệt. Nhưng với sự trợ giúp của <a href=https://new.babeljs.io/docs/en/next/babel-preset-env.html>babel-preset-env</a> (đã hỗ trợ hết ES 6, 7, 8) thì chúng ta hoàn toàn có thể transpile để sử dụng <code>async</code>, <code>await</code> trên các trình duyệt phiên bản cũ hơn.</p> <p>Async/await được xây dựng dựa trên generator và Promise, nó được xây dựng tương đối giống với ý tưởng của hàm <code>async</code> tổng quát ở phần trước, tất nhiên là phức tạp và bao quát hơn. Để tìm hiểu rõ hơn về các xây dựng những keyword này, mời các bạn xem thêm <a href=https://tc39.github.io/ecmascript-asyncawait/#desugaring>ở đây</a>.</p> <p>Trong bài viết này, chúng ta chủ yếu tập trung vào cách áp dụng những keyword này cho bài toán bất đồng bộ.</p> <h2 id=ham-async>Hàm <code>async</code><a class=headerlink href=#ham-async title="Permanent link">&para;</a></h2> <p>Chúng ta có thể định nghĩa một hàm bất đồng bộ bằng keyword <code>async</code>:</p> <div class=codehilite><pre><span></span><span class=nx>async</span> <span class=kd>function</span> <span class=nx>fname</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Hoặc định nghĩa bằng function expression cũng không vấn đề gì:</p> <div class=codehilite><pre><span></span><span class=nx>fname</span> <span class=o>=</span> <span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Thậm chí, chúng ta có thể kết hợp với cú pháp arrow function của ES 6:</p> <div class=codehilite><pre><span></span><span class=nx>fname</span> <span class=o>=</span> <span class=nx>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=mi>1</span><span class=p>;</span>
</pre></div> <p>Keyword <code>async</code> trong định nghĩa hàm trên sẽ giúp chúng ta định nghĩa một hàm thuộc lớp <code>AsyncFunction</code>. Lưu ý rằng, <code>AsyncFunction</code> không thể truy cập như một biến toàn cục được nên muốn định nghĩa một hàm bất đồng bộ, chúng ta bắt buộc phải dùng đến keyword <code>async</code>.</p> <p>AsyncFunction cũng không khác các hàm thông thường nhiều lắm, ngoại trừ nó luôn luôn <code>return</code> một promise. Nếu trong code không <code>return</code> một promise nào cả, thì một promise mới được resolve với giá trị được <code>return</code> trong code (sẽ là <code>undefined</code> nếu không có giá trị nào được return).</p> <p>Và vì là một promise được trả về, chúng ta có thể dùng nó với callback như các promise khác:</p> <div class=codehilite><pre><span></span><span class=nx>fname</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
</pre></div> <p>Nếu trong trường hợp hàm async trả về một promise, thì càng tốt, không cần phải chuyển đổi giá trị thành promise được resolve nữa, khi đó, thực ra <code>async</code> có hay không cũng như nhau cả:</p> <div class=codehilite><pre><span></span><span class=nx>another_func</span> <span class=o>=</span> <span class=nx>async</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
<span class=nx>another_func</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 2</span>
</pre></div> <p>Vậy là keyword <code>async</code> luôn đảm bảo một hàm sẽ trả về một promise. Tất nhiên, một hàm không async cũng có thể trả về một promise cũng không sao cả. Nhưng <code>async</code> còn cho chúng ta một khả năng tuyệt vời hơn: sử dụng <code>async</code> kết hợp với <code>await</code>.</p> <h2 id=await>Await<a class=headerlink href=#await title="Permanent link">&para;</a></h2> <p>Câu lệnh <code>await</code> sẽ giúp chúng ta "tạm dừng" việc thực thi các code trong một hàm async, chờ cho đến khi promise được resolve thì mới tiếp tục thực thi các code đó với giá tị được resolve. Keyword <code>await</code> chỉ có thể hoạt động bên trong một hàm async, nếu chúng ta gọi nó ở chỗ khác thì sẽ gặp lỗi <code>SyntaxError</code>. Cũng dễ hiểu thôi, phải ở bên trong một hàm thì mới có thể xác định được phạm vi code được để mà tạm dừng. Nếu chúng ta gọi <code>await</code> ở một nơi toàn cục chẳng hạn, rõ ràng là không thể xác định được code nào cần tạm dừng vì phạm vi quá rộng.</p> <p>Sự kết hợp với <code>async</code> và <code>await</code> giúp chúng ta đơn giản hoá code với các hoạt động bất đồng bộ (kết hợp với promise). Vì promise sẽ dễ dàng kết hợp với callback, <code>async</code> và <code>await</code> giúp chúng ta code đơn giản hơn bằng cách kết hợp generator và promise. Chúng ta hãy xem xét ví dụ sau:</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>promise</span> <span class=o>=</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=mi>1000</span><span class=p>));</span>
    <span class=nx>await</span> <span class=nx>promise</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;done&#39;</span><span class=p>);</span>
<span class=p>})();</span>
</pre></div> <p>Trong đoạn code trên, sau 1 giây, trên console sẽ hiển thị <code>1</code>. Hàm async của chúng ta đã được tạm dừng khi gặp câu lệnh <code>await</code>, và chờ 1 giấy cho promise được resolve và tiếp tục thực thi với kết quả được trả về.</p> <p>Bằng cách này, chúng ta có thể code bất đồng bộ theo phong cách tuần tự tương tự như các hoạt động đồng bộ mà không cần phải dùng callback. Điều đó giúp code dễ đọc và dễ hiểu hơn. Thậm chí chúng ta có thể sử dụng <code>await</code> nhiều lần nếu muốn nhiều hoạt động bất đồng bộ diễn ra lần lượt (như ở phần trước, chúng ta cần đến promise chain).</p> <p>Ví dụ load script nếu chuyển sang sử dụng async await có thể chuyển thành như sau:</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>(){</span>
    <span class=nx>await</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//code.jquery.com/jquery-3.3.1.min.js&#39;</span><span class=p>);</span>
    <span class=nx>await</span> <span class=nx>loadScript</span><span class=p>(</span><span class=s1>&#39;//cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js&#39;</span><span class=p>);</span>
    <span class=p>...</span>
<span class=p>})();</span>
</pre></div> <p>Một điều thú vị là <code>await</code> đúng ra phải đi kèm với promise, nhưng về mặt code thì không cần phải làm như vậy. Trong trường hợp phía sau <code>await</code> là một giá trị, nó sẽ được hiểu là một promise được resolve với giá trị đó.</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>(){</span>
    <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>await</span> <span class=mi>1</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
<span class=p>})()</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
</pre></div> <p>Và vì bản chất hoạt động bất đồng bộ là sử dụng một stack nên các đoạn code phía sau <code>await</code> đều được thực thi sau các code đồng bộ khác:</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>(){</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
    <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>await</span> <span class=mi>2</span><span class=p>;</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
<span class=p>})()</span>
<span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
<span class=c1>// 3</span>
<span class=c1>// 2</span>
</pre></div> <p>Lệnh <code>await</code> sẽ chờ promise được resolve và trả về kết quả được resolve đó (và sẽ tự convert một giá trị thành promise). Nhưng trong trường hợp promise bị reject, thì nó sẽ trả về một exception.</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>await</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>reject</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
<span class=p>})();</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// Uncaught (in promise) 1</span>
</pre></div> <p>Chúng ta sẽ tìm hiểu thêm về việc xử lý khi gặp lỗi trong phần sau.</p> <h2 id=phuong-thuc-async>Phương thức <code>async</code><a class=headerlink href=#phuong-thuc-async title="Permanent link">&para;</a></h2> <p>Trong phần trước chúng ta đã tìm hiểu về hàm <code>async</code>, với cú pháp ES2015, chúng ta có thể thêm <code>async</code> và trước các phương thức của một class để biến nó thành phương thức <code>async</code>.</p> <p>Về cơ bản, cách hoạt động của phương thức <code>async</code> cũng không khác nhiều so với hàm. Ví dụ:</p> <div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>Restaurant</span> <span class=p>{</span>
    <span class=nx>async</span> <span class=nx>takeOrder</span><span class=p>()</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nx>await</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
<span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=nx>await</span> <span class=p>(</span><span class=k>new</span> <span class=nx>Restaurant</span><span class=p>).</span><span class=nx>takeOrder</span><span class=p>();</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
<span class=p>})();</span>
<span class=c1>// Kết quả:</span>
<span class=c1>// 1</span>
</pre></div> <p>Lưu ý rằng, với tư tưởng thiết kế khác nhau, <code>async/await</code> hoạt động rất khác với promise chain. Cơ chế "tạm dừng - chạy tiếp" của nó nhiều lúc có thể khiến hai promise được chạy một cách song song như ví dụ sau:</p> <div class=codehilite><pre><span></span><span class=kd>var</span> <span class=nx>resolveAfter2Seconds</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;starting slow promise&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>resolve</span><span class=p>(</span><span class=mi>20</span><span class=p>);</span>
            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;slow promise is done&quot;</span><span class=p>);</span>
        <span class=p>},</span> <span class=mi>2000</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>};</span>

<span class=kd>var</span> <span class=nx>resolveAfter1Second</span> <span class=o>=</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;starting fast promise&quot;</span><span class=p>);</span>
    <span class=k>return</span> <span class=k>new</span> <span class=nb>Promise</span><span class=p>(</span><span class=nx>resolve</span> <span class=p>=&gt;</span> <span class=p>{</span>
        <span class=nx>setTimeout</span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
            <span class=nx>resolve</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
            <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&quot;fast promise is done&quot;</span><span class=p>);</span>
        <span class=p>},</span> <span class=mi>1000</span><span class=p>);</span>
    <span class=p>});</span>
<span class=p>};</span>

<span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;==CONCURRENT START with await==&#39;</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>slow</span> <span class=o>=</span> <span class=nx>resolveAfter2Seconds</span><span class=p>();</span>
    <span class=kr>const</span> <span class=nx>fast</span> <span class=o>=</span> <span class=nx>resolveAfter1Second</span><span class=p>();</span>

    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>await</span> <span class=nx>slow</span><span class=p>);</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>await</span> <span class=nx>fast</span><span class=p>);</span>
<span class=p>})();</span>
</pre></div> <p>Trong hàm async ở trên, cả <code>slow</code> và <code>fast</code> đều được tạo ra và <code>await</code>. Hai promise tương ứng đều được thực thi nhưng <code>await</code> đã tạm dừng chúng lại và nó chỉ thực thi tiếp khi promise được resolve. Vì vậy với đoạn code trên, nó sẽ mất 2 giây để thực thi, và việc thực thi await là lần lượt nên kết quả của <code>slow</code> và <code>fast</code> sẽ lần lượt xuất hiện.</p> <p>Trong trường hợp này, cách hoạt động của nó giống với <code>Promise.all</code> nhiều hơn. Nếu muốn một hoạt động song song thực sự thì <code>await</code> không phải là lựa chọn tốt, mà cách tốt nhất là sử dụng <code>Promise.then</code>, khi đó, promise nào kết thúc trước sẽ xuất hiện kết quả trước.</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;==PARALLEL with Promise.then==&#39;</span><span class=p>);</span>
    <span class=nx>resolveAfter2Seconds</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
    <span class=nx>resolveAfter1Second</span><span class=p>().</span><span class=nx>then</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
<span class=p>})()</span>
</pre></div> <h2 id=viet-lai-promise-chain-bang-asyncawait>Viết lại promise chain bằng <code>async/await</code><a class=headerlink href=#viet-lai-promise-chain-bang-asyncawait title="Permanent link">&para;</a></h2> <p>JavaScript hiện nay có <code>fetch</code> API sẽ gửi truy vấn đến 1 URL và trả kết quả về là một promise. Promise được trả về này hoàn toàn có thể được sử dụng bởi promise chain, ví dụ như sau:</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;https://jsonplaceholder.typicode.com/posts/1&#39;</span><span class=p>)</span>
        <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>response</span> <span class=p>=&gt;</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>())</span>
        <span class=p>.</span><span class=nx>then</span><span class=p>(</span><span class=nx>json</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>json</span><span class=p>))</span>
<span class=p>})();</span>
<span class=c1>// Kết quả</span>
<span class=c1>// {</span>
<span class=c1>//     userId: 1,</span>
<span class=c1>//     id: 1,</span>
<span class=c1>//     title: &quot;sunt aut facere repellat provident occaecati...&quot;,</span>
<span class=c1>//     body: &quot;quia et suscipit recusandae consequuntur...&quot;</span>
<span class=c1>// }</span>
</pre></div> <p>Hoàn toàn có thể được viết lại bằng <code>async/await</code> như sau:</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=kr>const</span> <span class=nx>response</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;https://jsonplaceholder.typicode.com/posts/1&#39;</span><span class=p>);</span>
    <span class=kr>const</span> <span class=nx>json</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>response</span><span class=p>.</span><span class=nx>json</span><span class=p>();</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>json</span><span class=p>);</span>
<span class=p>})();</span>
</pre></div> <h2 id=xu-ly-loi>Xử lý lỗi<a class=headerlink href=#xu-ly-loi title="Permanent link">&para;</a></h2> <p>Trong những phần trên, chúng ta mới chỉ quan tâm đến <code>aysnc/await</code> khi mà mọi việc đều diễn ra bình thường, nghĩa là promise hoạt động và resolve một kết quả. Thế nhưng, trong trường hợp promise bị reject, với những code thông thường thì một exception sẽ xảy ra, và với hàm async thì mọi chuyện cũng giống như vậy:</p> <p>Đoạn code này</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=nx>await</span> <span class=nb>Promise</span><span class=p>.</span><span class=nx>reject</span><span class=p>(</span><span class=k>new</span> <span class=nb>Error</span><span class=p>());</span>
<span class=p>})();</span>
</pre></div> <p>cũng giống như đoạn code này</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span> <span class=nx>f</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>throw</span> <span class=k>new</span> <span class=nb>Error</span><span class=p>();</span>
<span class=p>})();</span>
</pre></div> <p>đều sẽ cho ra một exception</p> <div class=codehilite><pre><span></span><span class=nx>Uncaught</span> <span class=p>(</span><span class=k>in</span> <span class=nx>promise</span><span class=p>)</span> <span class=nb>Error</span>
</pre></div> <p>Và cũng giống như những hàm thông thường khác, chúng ta có thể sử dụng <code>try..catch</code> để xử lý khi gặp những exception này:</p> <div class=codehilite><pre><span></span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>try</span> <span class=p>{</span>
        <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>doSomething</span><span class=p>();</span>
        <span class=kr>const</span> <span class=nx>newResult</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>doSomethingElse</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
        <span class=kr>const</span> <span class=nx>finalResult</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>doThirdThing</span><span class=p>(</span><span class=nx>newResult</span><span class=p>);</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=sb>`Got the final result: </span><span class=si>${</span><span class=nx>finalResult</span><span class=si>}</span><span class=sb>`</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=nx>error</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>failureCallback</span><span class=p>(</span><span class=nx>error</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</pre></div> <p>Trong nhiều trường hợp, một promise có thể sẽ mất thời gian thực thi rồi mới bị reject vì vậy, exception cũng phải chờ một lúc mới xảy ra.</p> <div class=codehilite><pre><span></span><span class=p>(</span><span class=nx>async</span> <span class=kd>function</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>try</span> <span class=p>{</span>
        <span class=kd>let</span> <span class=nx>response</span> <span class=o>=</span> <span class=nx>await</span> <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;http://no-such-url&#39;</span><span class=p>);</span>
    <span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
        <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>err</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>})();</span>
</pre></div> <p>Trong trường hợp hàm async, <code>try..catch</code> cũng hoạt động giống như các hàm thông thường khác, khi gặp exception, code của <code>catch</code> gần nhất sẽ được thực thi. Tuy nhiên, chúng ta không thể sử dụng <code>try..catch</code> ở bên ngoài hàm async được, cũng giống như chúng ta không thể <code>try..catch</code> với promise vậy:</p> <div class=codehilite><pre><span></span><span class=nx>async</span> <span class=kd>function</span> <span class=nx>f</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>await</span> <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;http://no-such-url&#39;</span><span class=p>);</span>
<span class=p>};</span>

<span class=k>try</span> <span class=p>{</span>
    <span class=nx>f</span><span class=p>()</span>
<span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span> <span class=p>{</span>
    <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>err</span><span class=p>);</span>
<span class=p>}</span>
<span class=c1>// try catch này không có tác dụng</span>
<span class=c1>// exception vẫn cứ xảy ra mà không bị catch</span>
</pre></div> <p>Nếu muốn xử lý exception ở bên ngoài hàm async thì chúng ta vẫn có thể sử dụng cơ chế callback thông thường với <code>Promise.catch</code> hoặc <code>Promise.then(null, function)</code>. Bởi vì hàm async sẽ trả về một promise, chúng ta dễ dàng sử dụng cơ chế này:</p> <div class=codehilite><pre><span></span><span class=nx>async</span> <span class=kd>function</span> <span class=nx>f</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=nx>await</span> <span class=nx>fetch</span><span class=p>(</span><span class=s1>&#39;http://no-such-url&#39;</span><span class=p>);</span>
<span class=p>};</span>

<span class=nx>f</span><span class=p>().</span><span class=k>catch</span><span class=p>(</span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>);</span>
</pre></div> <h1 id=ket-luan>Kết luận<a class=headerlink href=#ket-luan title="Permanent link">&para;</a></h1> <p>Cặp keyworkd <code>async/await</code> cho chúng ta cơ chế "tạm dừng - chạy tiếp" rất hay, giúp công việc code bất đồng bộ dễ dàng hơn bao giờ hết. Giờ đây, chúng ta có thể code bất đồng bộ không khác gì code đồng bộ cả. Điều đó giúp code dễ đọc và dễ hiểu hơn.</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#JavaScript</span> <span>#Promise</span> <span>#async</span> <span>#await</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2018/Aug/20/python-object-mutable-and-immutable.html> Newer Post </a> </span> <span class=older-link> <a href=/2018/Jun/20/javascript-promise.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>