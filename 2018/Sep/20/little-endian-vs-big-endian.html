<!DOCTYPE html><title>Little endian vs. Big endian - manhhomienbienthuy's space</title> <meta charset=utf-8> <meta name=viewport content="width=device-width, initial-scale=1"> <link rel=apple-touch-icon href=/theme/images/icon-touch.png> <link rel=icon sizes=192x192 href=/theme/images/icon-touch.png> <link rel="shortcut icon" href=/theme/images/favicon.ico> <link rel=author href=/humans.txt> <meta name=msapplication-TileImage content=/theme/images/icon-tile.png> <meta name=twitter:dnt content=on> <meta name=Author content=manhhomienbienthuy> <meta name=rating content=general> <meta name=twitter:card content=product> <meta name=twitter:site content=@_naa_4f> <meta name=twitter:creator content=@_naa_4f> <link href=/feeds/all.atom.xml type=application/atom+xml rel=alternate title="manhhomienbienthuy's space Full Atom Feed"> <meta name=description content="Little endian và big endian, đây là hai phương thức khác nhau để lưu trữ dữ liệu dạng nhị phân (binary). Bình thường thì chúng ta cũng chẳng cần quan tâm đến chúng làm gì. Bởi mọi việc sẽ được tự động hoá hết. Thế nhưng có những tình huống …"> <meta name=keywords content="Fundamentals, Endian, Binary, blog, naa, manhhomienbienthuy, pelican, static site generator"> <meta name=twitter:title content="Little endian vs. Big endian - manhhomienbienthuy's space"> <meta name=twitter:description content="Little endian và big endian, đây là hai phương thức khác nhau để lưu trữ dữ liệu dạng nhị phân (binary). Bình thường thì chúng ta cũng chẳng cần quan tâm đến chúng làm gì. Bởi mọi việc sẽ được tự động hoá hết. Thế nhưng có những tình huống …"> <meta name=twitter:image content=/https://i.imgur.com/Ifm1Lkq.png> <link rel=stylesheet href=//cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css> <link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.0.0/css/font-awesome.min.css> <link rel=stylesheet href=/theme/css/vpyeu.min.css?5d2c7d5e> <header> <div class=navbar> <div class=wrapper> <div class=nav-menu> <div class=menu-toggle> <i class="fa fa-reorder"></i> </div> <ul class=menus> <li><a href=/ >Home</a> <li><a href=/category/general.html> General <li><a href=/category/life.html> Life <li><a href=/category/programming.html class=current> Programming <li><a href=/category/travel.html> Travel </ul> </div><div class="right links"> <ul> <li> <a href=https://twitter.com/_naa_4f target=_blank> <i class="fa fa-twitter"></i> </a> <li> <a href=https://instagram.com/manhhomienbienthuy/ target=_blank> <i class="fa fa-instagram"></i> </a> <li> <a href=https://www.facebook.com/manhhomienbienthuy target=_blank> <i class="fa fa-facebook"></i> </a> <li> <a href=https://github.com/manhhomienbienthuy target=_blank> <i class="fa fa-github"></i> </a> <li> <a href=/feeds/all.atom.xml target=_blank> <i class="fa fa-rss"></i> </a> </ul> </div> </div> </div><noscript> <div class="warning head-warn"> <div class=wrapper> <p><strong>Notice:</strong> While JavaScript is not essential for this website, your interaction with the content will be limited. Please turn JavaScript on for the full experience. </div> </div> </noscript><div class=banner> <div class=wrapper> <a href=/ > <img alt="manhhomienbienthuy's space" src=/theme/images/logo.png> </a> </div> </div></header> <main> <div class=wrapper> <div class=main-wrapper> <div class=entry> <div class=entry-detail> <div class=post> <h1 class=title> Little endian vs. Big endian </h1> <div class=meta> Posted in <a href=/category/programming.html>Programming</a> on September 20, 2018 by <a href=/pages/about-me.html>manhhomienbienthuy</a> <span class=right> <i class="fa fa-comments"></i> <a href=#disqus_thread data-disqus-identifier=/2018/Sep/20/little-endian-vs-big-endian.html> Comments </a> </span> </div> <div class=post-body> <img src=https://i.imgur.com/Ifm1Lkq.png alt="Little endian vs. Big endian"> <p>Little endian và big endian, đây là hai phương thức khác nhau để lưu trữ dữ liệu dạng nhị phân (binary). Bình thường thì chúng ta cũng chẳng cần quan tâm đến chúng làm gì. Bởi mọi việc sẽ được tự động hoá hết.</p> <p>Thế nhưng có những tình huống, ví dụ khi phải xử lý các tập tin có cấu trúc, tập tin binary, nhất là những tập tin được ghi bằng ngôn ngữ khác, thì việc hiểu về little endian và big endian là rất quan trọng. Bởi nếu không, rất có thể chúng ta sẽ đọc sai thứ tự và xử lý với dữ liệu được hiểu sai.</p> <h1 id=du-lieu>Dữ liệu<a class=headerlink href=#du-lieu title="Permanent link">&para;</a></h1> <p>Dữ liệu là thể hiện của thông tin dưới dạng lưu trữ được. Thông tin là thứ trừu tượng, không có hình dạng, đó là những hiểu biết về các sự vật, sự việc xung quanh chúng ta. Để lưu trữ, cũng như truyền đạt thông tin đến mọi người, chúng ta cần đến dữ liệu. Dữ liệu có thể là chữ viết, hình ảnh được ghi trên giấy, tất cả chúng ta dữ liệu mà con người có thể hiểu được.</p> <p>Nhưng những dữ liệu đó cần phải được mã hoá một lần nữa, nếu chúng ta muốn lưu trữ chúng trên máy tính. Như chúng ta đều biết, máy tính chỉ làm việc với dữ liệu được mã hoá dưới dạng nhị phân, vậy nên mọi dữ liệu cần được mã hoá thành nhị phân mới có thể xử lý trên máy tính được.</p> <blockquote> <p>Thực ra điều này chỉ đúng với máy tính số (digital electronic computer). Nghe nói hiện nay máy tính lượng tử, máy tính sinh học cũng đang được phát triển, hy vọng trong vài năm tới, chúng ta sẽ update lại kiến thức về dữ liệu.</p> </blockquote> <p>Thực ra, máy tính không hiểu được các ký tự 0, 1 trong hệ nhị phân đâu, nó hoạt động theo các tín hiệu điện tử. Mô tả chính xác thì rất khó, nhưng chúng ta có thể hiểu "sơ sơ" rằng, gặp bit 1 thì sẽ có dòng diện, gặp bit 0 thì không có. Như vậy, các bit 0, 1 được xử lý thành các tín hiệu điện tử tương ứng, và chúng ta coi đó như máy tính đã hiểu được dữ liệu nhị phân.</p> <p>Thế nhưng, mặc dù cùng sử dụng tín hiệu dạng nhị phân, các máy tính khác nhau cũng không thực sự nói chung một ngôn ngữ. Cũng giống như coi người vậy, khi nhìn các ký tự <code>a</code>, <code>b</code>, <code>c</code> có người hiểu, có người không. Máy tính khi nhìn vào các tín hiệu tương ứng với các ký hiệu <code>0</code> hay <code>1</code>, mỗi máy tính có thể hiểu theo một cách khác nhau.</p> <p>Thế nhưng, rất may là các máy tính vẫn hoạt động theo những tiêu chuẩn chung, thế nên nó vẫn có thể giao tiếp với nhau được. Tuy nhiên, lưu ý rằng, không phải bất cứ lúc nào, các máy tính cũng có thể hiểu được lẫn nhau.</p> <p>Trong máy tính, các dữ liệu nhị phân không được xử lý theo từng bit riêng lẻ, mà được xử lý thành từng khối 8 bit một, và đơn vị xử lý nhỏ nhất này gọi là byte.</p> <p>Ví dụ, số nguyên <code>123456789</code> được biểu diễn dưới dạng nhị phân sẽ là (ở đây tôi cho rằng kiểu dữ liệu <code>int</code> sẽ có kích thước là 4 byte, tuy nhiên, nhiều hệ thống 64 bit đã nâng kích thước này lên 8 byte)</p> <div class=codehilite><pre><span></span>00000111 01011011 11001101 00010101
</pre></div> <p>Để ngắn gọn, chúng ta có thể viết nó dưới dạng hexa như sau:</p> <div class=codehilite><pre><span></span>07 5b cd 15
</pre></div> <p>Đã có bao giờ, bạn tự hỏi, khi ghi dữ liệu này trên đĩa cứng chẳng hạn, nó được ghi thế nào chưa. Bạn cho rằng, nó sẽ được ghi lần lượt theo thứ tự mà chúng ta đang đọc và viết ở trên, thì bạn đã nhầm.</p> <p>Đây là cách viết theo kiểu số Ả rập cho chúng ta dễ hiểu thôi, máy tính không "đọc" các ký tự giống như chúng ta nên nó cũng không lưu trữ giống cách chúng ta viết các ký tự này ra đâu. Việc ghi dữ liệu như thế nào chính là lúc little endian và big endian được dùng đến.</p> <h1 id=little-endian-va-big-endian-la-gi>Little endian và big endian là gì?<a class=headerlink href=#little-endian-va-big-endian-la-gi title="Permanent link">&para;</a></h1> <p>Little endian và big endian là hai phương thức khác nhau để lưu trữ dữ liệu. Sự khác biệt của little endian và big endian khi lưu trữ chính là ở việc sắp xếp thứ tự các byte dữ liệu.</p> <p>Trong cơ chế lưu trữ little endian (xuất phát từ "little-end" nghĩa kết thúc nhỏ hơn), byte cuối cùng trong biểu diễn nhị phân trên sẽ được ghi trước. Ví dụ <code>123456789</code> ghi theo kiểu little endian sẽ thành</p> <div class=codehilite><pre><span></span>15 cd 5b 07
</pre></div> <p>Hơi ngược một chút đúng không? Big endian (xuất phát từ "big-end") thì ngược lại, là cơ chế ghi dữ liệu theo thứ tự bình thường mà chúng ta vẫn dùng. <code>123456789</code> được lưu trữ vẫn theo đúng thứ tự là</p> <div class=codehilite><pre><span></span>07 5b cd 15
</pre></div> <p>Các thuật ngữ big-end hay little-end xuất phát từ cuốn tiểu thuyết Gulliver du ký (Gulliver's Travels), trong đó nhân vật Lilliputans tranh luận về việc nên đập trứng bằng đầu to hay nhỏ.</p> <p>Và ngành IT đã ứng dụng thuật ngữ ngày, tương đối giống với nghĩa gốc. Lưu ý rằng, little endian hay big endian chỉ khác nhau ở cách sắp xếp các <strong>byte</strong> dữ liệu, còn thứ tự từng bit trong byte thì giống nhau. Rất may, các máy tính vẫn có điểm trung này.</p> <p>Thêm một lưu ý nữa rằng, little endian hay big endian chỉ khác biệt khi cần lưu trữ những dữ liệu có nhiều byte. Những dữ liệu chỉ có 1 byte (ví dụ ký tự ASCII) thì không ảnh hưởng gì (chính xác là dù dùng phương thức nào kết quả cũng như nhau)</p> <h1 id=little-endian-va-big-endian-uoc-dung-tren-nhung-may-tinh-nao>Little endian và big endian được dùng trên những máy tính nào?<a class=headerlink href=#little-endian-va-big-endian-uoc-dung-tren-nhung-may-tinh-nao title="Permanent link">&para;</a></h1> <p>Việc sắp xếp các byte dữ liệu theo kiểu little endian hay big endian không chỉ xảy ra khi chúng ta lưu trữ dữ liệu ra bộ nhớ ngoài. Mọi hoạt động của máy tính đều sử dụng dữ liệu nhị phân, nên little endian/big endian hiện hữu trong mọi hoạt động của máy tính.</p> <p>Ngoài việc sử dụng little endian/big endian một phần phụ thuộc vào phần mềm (do lập trình viên cố ý sử dụng một trong hai loại, hoặc ngôn ngữ lập trình quy định trước), nó còn phụ thuộc vào bộ vi xử lý của chính máy tính đó.</p> <p>Các bộ vi xử lý Intel đều sử dụng little endian, các bộ vi xử lý cả ARM trước đây cũng là little endian, nhưng hiện này ARM đã nâng cấp vi xử lý của mình thành bi-endian (tức là xử lý cả little endian và big endian).</p> <p>Các bộ vi xử lý PowerPC và SPARK trước đây đều là big endian, nhưng hiện nay chúng cũng được nâng cấp thành bi-endian.</p> <h1 id=cac-lam-nao-thi-tot-hon-little-endian-hay-big-endian>Các làm nào thì tốt hơn: little endian hay big endian?<a class=headerlink href=#cac-lam-nao-thi-tot-hon-little-endian-hay-big-endian title="Permanent link">&para;</a></h1> <p>Little endian hay big endian cũng như tranh luận gốc về việc đập trứng, không có một phương thức nào thực sự tốt hơn phương thức nào.</p> <p>Little endian hay big endian chỉ khác nhau ở việc lưu trữ thứ tự các byte dữ liệu. Cả hai phương thức đều không làm ảnh hưởng đến tốc độ xử lý của CPU. Thế nên cả hai phương thức đều vẫn tồn tại song song và sẽ không bao giờ có thể có một câu trả lời thoả đáng: Phương thức nào thì tốt hơn?</p> <p>Mỗi phương thức đều có những lợi thế nhất định. Với little endian, vì byte nhỏ nhất luôn nằm bên trái, nó sẽ cho phép chúng ta đọc dữ liệu với độ dài tuỳ ý. Nó sẽ rất thích hợp nếu chúng ta cần ép kiểu, ví dụ từ <code>int</code> thành <code>long int</code>.</p> <p>Với giả định <code>int</code> là 4 byte, <code>long int</code> là 8 byte, nếu dùng little endian, khi ép kiểu, địa chỉ bộ nhớ không cần phải thay đổi, chúng ta chỉ cần ghi tiếp các byte lớn hơn mà thôi.</p> <p>Nhưng nếu cũng trường hợp đó, mà sử dụng big endian, thì chúng ta sẽ phải dịch địa chỉ bộ nhớ hiện tại thêm 4 byte nữa mới có không gian để lưu trữ.</p> <p>Nhưng big endian cũng có nhưng lợi thế nhất định, với việc đọc dữ liệu byte lớn nhất trước, nó sẽ rất dễ dàng kiểm tra một số là âm hay dương, do byte chứa dấu được đọc đầu tiên.</p> <h1 id=xem-cac-byte-du-lieu-trong-bo-nho>Xem các byte dữ liệu trong bộ nhớ<a class=headerlink href=#xem-cac-byte-du-lieu-trong-bo-nho title="Permanent link">&para;</a></h1> <p>Chương trình C đơn giản nhau cho chúng ta cách nhìn về việc sắp xếp các byte trong bộ nhớ.</p> <div class=codehilite><pre><span></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>

<span class=cm>/* function to show bytes in memory, from location start to start+n */</span>
<span class=kt>void</span>
<span class=nf>show_mem_rep</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
<span class=p>{</span>
  <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=n>printf</span> <span class=p>(</span><span class=s>&quot; %.2x&quot;</span><span class=p>,</span> <span class=n>start</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
  <span class=n>printf</span> <span class=p>(</span><span class=s>&quot;</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>);</span>
<span class=p>}</span>

<span class=cm>/* Main function to call above function for 0x01234567 */</span>
<span class=kt>int</span>
<span class=nf>main</span> <span class=p>()</span>
<span class=p>{</span>
  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mh>0x01234567</span><span class=p>;</span>
  <span class=n>show_mem_rep</span> <span class=p>((</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=k>sizeof</span> <span class=p>(</span><span class=n>i</span><span class=p>));</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Khi thực thi chương trình trên, nếu máy của bạn là little endian thì kết quả sẽ là</p> <div class=codehilite><pre><span></span> 67 45 23 01
</pre></div> <p>còn nếu máy bạn là big endian thì nó sẽ hiển thị theo thứ tự thông thường</p> <div class=codehilite><pre><span></span> 01 23 45 67
</pre></div> <p>Có cách nào để xác định máy tính của chúng ta là little endian hay big endian hay không? Có vô số các cách khác nhau, dưới đây là một trong số những cách đó:</p> <div class=codehilite><pre><span></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>

<span class=kt>int</span>
<span class=nf>main</span> <span class=p>()</span>
<span class=p>{</span>
  <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=kt>char</span> <span class=o>*</span><span class=n>c</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>i</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>c</span><span class=p>)</span>
    <span class=n>printf</span> <span class=p>(</span><span class=s>&quot;Little endian&quot;</span><span class=p>);</span>
  <span class=k>else</span>
    <span class=n>printf</span> <span class=p>(</span><span class=s>&quot;Big endian&quot;</span><span class=p>);</span>
  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Với đoạn code đơn giản trên, <code>c</code> là con trỏ, nó trỏ đến vùng nhớ của biến <code>i</code> là một số nguyên. Bởi vì số nguyên là kiểu dữ liệu nhiều byte, trong khí dữ liệu của <code>char</code> chỉ là một byte mà thôi, nên <code>*c</code> sẽ trả về giá trị là byte đầu tiên của số nguyên <code>i</code>.</p> <p>Nếu máy tính của chúng ta là little endian thì byte đầu tiên này sẽ là <code>1</code>, ngược lại thì nó sẽ là <code>0</code>.</p> <h1 id=ieu-nay-anh-huong-the-nao-en-viec-lap-trinh>Điều này ảnh hưởng thế nào đến việc lập trình<a class=headerlink href=#ieu-nay-anh-huong-the-nao-en-viec-lap-trinh title="Permanent link">&para;</a></h1> <p>Về cơ bản thì little endian hay big endian không có ảnh hưởng lắm đến việc lập trình. Phần lớn các lập trình viên không cần quan tâm nhiều lắm, bởi mọi việc đã được các trình biên dịch/thông dich đảm nhiệm hết.</p> <p>Tuy nhiên, một số trường hợp, chúng ta cần quan tâm, đặc biệt khi chuyển đổi dữ\ liệu giữa các máy tính khác nhau. Ví dụ: khi chúng ta cần xử lý một file có cấu trúc thế này, 4 byte đầu tiên là một số nguyên <code>n</code>, sau đó là n số nguyên, mỗi số chiếm 4 byte bộ nhớ, v.v...</p> <p>Trong trường hợp này, khi nhận file được tạo ra từ một máy tính khác, việc nó được ghi theo kiểu little endian hay big endian rõ ràng là ảnh hưởng rất nghiêm trọng, nếu sử dụng sai phương thức, chúng ta sẽ thu về dữ liệu sai.</p> <p>Một trường hợp khác nữa có thể xảy ra vấn đề là khi chúng ta ép kiểu cho các biến</p> <div class=codehilite><pre><span></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>

<span class=kt>int</span>
<span class=nf>main</span> <span class=p>()</span>
<span class=p>{</span>
  <span class=kt>unsigned</span> <span class=kt>char</span> <span class=n>arr</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mh>0x01</span><span class=p>,</span> <span class=mh>0x00</span> <span class=p>};</span>
  <span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>short</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span> <span class=n>arr</span><span class=p>;</span>
  <span class=n>printf</span> <span class=p>(</span><span class=s>&quot;%d&quot;</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Trong đoạn code trên, chúng ta đã ép kiểu một array hai phần tử <code>char</code> thành một số nguyên 2 byte (<code>short int</code>). Trong ví dụ này, little endian hay big endian cũng có ảnh hưởng rất lớn.</p> <p>Một máy tính dùng little endian sẽ có kết quả là <code>1</code> trong khi big endian sẽ cho kết quả là <code>256</code>. Để tránh những lỗi đáng tiếc có thể xảy ra, những code như trên cần phải tránh.</p> <h1 id=van-e-nuxi>Vấn đề NUXI<a class=headerlink href=#van-e-nuxi title="Permanent link">&para;</a></h1> <p>NUXI là một vấn đề rất nổi tiếng liên quan đến little endian và big endian: UNIX được lưu trong một hệ thống big-endian sẽ được hiểu là NUXI trong một hệ thống little endian.</p> <p>Giả sử chúng ta cần lưu trữ 4 byte (<code>U</code>, <code>N</code>, <code>I</code>, <code>X</code>) bằng hai số nguyên dạng <code>short int</code>: <code>UN</code> và <code>IX</code>.</p> <div class=codehilite><pre><span></span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>

<span class=kt>int</span>
<span class=nf>main</span> <span class=p>()</span>
<span class=p>{</span>
  <span class=kt>short</span> <span class=kt>int</span> <span class=o>*</span><span class=n>s</span><span class=p>;</span> <span class=c1>// pointer to set shorts</span>
  <span class=n>s</span> <span class=o>=</span> <span class=p>(</span><span class=kt>short</span> <span class=kt>int</span> <span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>short</span> <span class=kt>int</span><span class=p>));</span>    <span class=c1>// point to location 0</span>
  <span class=o>*</span><span class=n>s</span> <span class=o>=</span> <span class=s>&quot;UN&quot;</span><span class=p>;</span>  <span class=c1>// store first short: U * 256 + N (fictional code)</span>
  <span class=n>s</span> <span class=o>+=</span> <span class=mi>2</span><span class=p>;</span>    <span class=c1>// point to next location</span>
  <span class=o>*</span><span class=n>s</span> <span class=o>=</span> <span class=s>&quot;IX&quot;</span><span class=p>;</span>  <span class=c1>// store second short: I * 256 + X</span>

  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> <p>Đoạn code trên hoàn toàn độc lập với hệ thống, bất kể nó là little hay big endian. Nếu chúng ta lưu trữ các giá trị "UN" và "IX" khi đọc ra, nó vẫn sẽ là "UNIX" hay không? Nếu mọi việc chỉ xảy ra trên một máy tính, dù là big endian hay little endian thì nó sẽ luôn là như vậy, bởi mọi thứ sẽ được tự động hoá giúp chúng ta.</p> <p>Với bất cứ dữ liệu nào cũng vậy, chúng ta luôn thu được dữ liệu đúng nếu đọc và ghi trong cùng một hệ thống. Thế nhưng, hãy xem xét kỹ hơn về việc sắp xếp các byte trong bộ nhớ.</p> <p>Một hệ thống big endian sẽ lưu trữ như sau:</p> <div class=codehilite><pre><span></span>U N I X
</pre></div> <p>Còn một hệ thống little endian thì sẽ như sau:</p> <div class=codehilite><pre><span></span>N U X I
</pre></div> <p>Mặc dù trông hơi ngược nhưng hệ thống little endian sẽ xử lý việc đọc giúp chúng ta, nên lưu trữ như vậy nhưng khi lấy ra chúng ta vẫn có dữ liệu ban đầu. Thế nhưng khi chúng ta ghi dữ liệu này ra file, chuyển sang một máy tính khác. Và mỗi máy tính lại xử lý theo cách riêng của nó thì UNIX trên máy big endian sẽ được hiểu là NUXI trên máy little endian (và ngược lại).</p> <p>Đây chính là vấn đều nguy hiểm nhất khi chúng ta trao đỏi dữ liệu qua lại giữa các máy tính với nhau, đặc biệt trong thời đại Internet ngày nay.</p> <h1 id=trao-oi-du-lieu-giua-cac-may-co-endian-khac-nhau>Trao đổi dữ liệu giữa các máy có endian khác nhau<a class=headerlink href=#trao-oi-du-lieu-giua-cac-may-co-endian-khac-nhau title="Permanent link">&para;</a></h1> <p>Ngày nay, mọi máy tính đều được kết nối để trao đổi dữ liệu với nhau. Little endian hay big endian cũng đều phải trao đổi với nhau, nhưng làm thế nào để có hiểu được nhau khi chúng không nói chung một thứ tiếng?</p> <p>Có 2 giải pháp chính cho việc này</p> <h2 id=su-dung-chung-inh-dang>Sử dụng chung định dạng<a class=headerlink href=#su-dung-chung-inh-dang title="Permanent link">&para;</a></h2> <p>Một phương án đơn giản nhất tất cả sử dụng chung một định dang khi truyền dữ liệu.</p> <p>Ví dụ những tập tin dạng PNG đều bắt buộc phải sử dụng big endian. Tương tự với các tập tin có cấu trúc khác. Đó là lý do vì sao chúng ta nhiều khi cần phải dùng những phần mềm chuyên dụng để đọc và ghi các file này.</p> <p>Thế nhưng trong kết nối với Internet, việc truyền dữ liệu còn phức tạp hơn thế. Chúng ta không thể cứ dùng một định dạng file nào đó, rồi truyền từng byte một sang máy khác được. Muốn tăng tốc độ, bắt buộc chúng ta phải truyền nhiều byte một lúc.</p> <p>Và khi đó chúng ta cần có một chuẩn chung. Hiện nay, chuẩn chung cho việc truyền dữ liệu trên mạng, gọi là <a href=https://tools.ietf.org/html/rfc1700#page-3>network byte order</a> chính là big endian. Thế nhưng, dù đã chuẩn chung rồi, thỉnh thoảng vẫn có những giao thức chơi chội hơn, sử dụng little endian.</p> <p>Để có thể chuyển đổi dữ liệu thành dữ liệu chuẩn theo network byte order, chương trình cần gọi hàm <code>hton*</code> (host-to-network) (trong ngôn ngữ C). Trong hệ thống big endian, hàm này không cần làm gì cả, còn little endian sẽ thực hiện chuyển đối các byte một chút.</p> <p>Dù hệ thống big endian không cần chuyển đổi dữ liệu, việc gọi hàm này vẫn là rất cần thiết. Chương trình của chúng ta có thể được viết bằng một ngôn ngữ (C) nhưng có thể được dịch và thực thi ở nhiều hệ thống khác nhau, việc gọi hàm này sẽ giúp chúng ta làm điều đó.</p> <p>Tương tự, ở chiều ngược lại, chúng ta cần gọi hàm <code>ntoh*</code> để chuyển đổi dữ liệu nhận được từ mạng về dữ liệu máy tính có thể hiểu được. Ngoài ra, chúng ta còn phải hiểu rõ kiểu dữ liệu mà chúng ta cần chuyển đổi nữa, danh sách các hàm chuyển đổi như sau:</p> <ul> <li><code>htons</code> - "Host to Network Short"</li> <li><code>htonl</code>- "Host to Network Long"</li> <li><code>ntohs</code> - "Network to Host Short"</li> <li><code>ntohl</code> - "Network to Host Long"</li> </ul> <p>Những hàm này vô cùng quan trọng khi thực hiện chia sẽ dữ liệu ở tầng thấp, ví dụ khi kiểm tra checksum của các gói tin chẳng hạn. Nếu không hiểu rõ về little endian và big endian thì khi cần làm việc về mạng, bạn sẽ gặp nhiều khó khăn.</p> <h2 id=su-dung-bom-byte-order-mark>Sử dụng BOM (Byte Order Mark)<a class=headerlink href=#su-dung-bom-byte-order-mark title="Permanent link">&para;</a></h2> <p>Một phương án khác để giải quyết sự khác biệt về endian là sử dụng BOM (<a href=https://www.unicode.org/versions/Unicode5.0.0/ch16.pdf#G25817>Byte Order Mark</a>). Đây là một ký tự đặc biệt, có giá trị là <code>0xFEFF</code>, được ghi ở vị trí đầu tiên của file.</p> <p>Nếu bạn đọc ký tự này là <code>0xFFFE</code> (bị ngược) thì có nghĩa file này được ghi với endian khác với hệ thống của bạn, khi đó, bạn sẽ cần phải thay đổi phương thức đọc dữ liệu một chút.</p> <p>Có một vài vấn đề nhỏ với việc sử dụng BOM. Thứ nhất, BOM sẽ gây tăng dữ liệu được ghi vào file. Ngay cả khi chúng ta chỉ gửi đi 2 byte dữ liệu, chúng ta vẫn cần thêm 2 byte BOM nữa.</p> <p>Thứ hai, BOM không hoàn toàn thần thánh, bởi nó phụ thuộc vào lập trình viên. Có người có tâm thì đọc và xử lý khi gặp BOM, có người thì hoàn toàn bỏ quên nó và coi nói như dữ liệu thông thường. Unicode sử dụng BOM khi lưu trữ dữ liệu nhiều byte (nhiều ký tự Unicode được mã hoá thành 2, 3 thậm chí là 4 byte).</p> </div> <div class=post-footer> <div class=tags> <i class="fa fa-tags"></i> <span>#Fundamentals</span> <span>#Endian</span> <span>#Binary</span> </div> </div> </div><div class=blog-pager> <span class=newer-link> <a href=/2018/Oct/08/singapore-travel.html> Newer Post </a> </span> <span class=older-link> <a href=/2018/Aug/20/python-object-mutable-and-immutable.html> Older Post </a> </span> </div><div class=comments> <div class=finally> <p><em>I apologise for any typos. If you notice a problem, please let me know.</em> <p>Thank you all for your attention. </div> <div id=disqus_thread></div> <script src=/theme/js/disqus.min.js?81e8a5f5></script> <noscript> Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript> comments powered by Disqus. </a> </noscript> </div></div> </div> </div> <div class=sidebar-wrapper> <div class=widget> <h2>Welcome</h2> <div> <img src=/theme/images/banner.gif alt=Welcome> </div> </div><div class="widget recent-posts"> <h2>Recent Posts</h2> <ul> <li> <a href=/2019/May/20/elasticsearch-data-organization.html> <img alt="Elasticsearch: Data organization" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-data-organization.html>Elasticsearch: Data organization</a> <li> <a href=/2019/May/20/elasticsearch-intro.html> <img alt="Elasticsearch: Intro" src=https://i.imgur.com/JT4y7Qf.jpg> </a> <a href=/2019/May/20/elasticsearch-intro.html>Elasticsearch: Intro</a> <li> <a href=/2019/Apr/20/javascript-popups.html> <img alt="JavaScript: Popups" src=https://i.imgur.com/FxmcwPy.png> </a> <a href=/2019/Apr/20/javascript-popups.html>JavaScript: Popups</a> <li> <a href=/2019/Mar/20/javascript-iterator-and-generator.html> <img alt="JavaScript: Iterator and generator" src=https://i.imgur.com/lev8iT9.jpg> </a> <a href=/2019/Mar/20/javascript-iterator-and-generator.html>JavaScript: Iterator and generator</a> <li> <a href=/2019/Feb/20/javascript-decorator.html> <img alt="JavaScript decorator" src=https://i.imgur.com/Sh3yLI0.png> </a> <a href=/2019/Feb/20/javascript-decorator.html>JavaScript decorator</a> </ul> </div><div class="widget labels"> <h2>Blog Archive</h2> <ul> <li> <a href=/2019/ > 2019 </a> <li> <a href=/2018/ > 2018 </a> <li> <a href=/2017/ > 2017 </a> <li> <a href=/2016/ > 2016 </a> <li> <a href=/2015/ > 2015 </a> <li> <a href=/2014/ > 2014 </a> <li> <a href=/2013/ > 2013 </a> <li> <a href=/2012/ > 2012 </a> <li> <a href=/2011/ > 2011 </a> <li> <a href=/2010/ > 2010 </a> </ul> </div><div class=widget> <h2>Twitter timeline</h2> <a class=twitter-timeline data-height=500 data-dnt=true data-theme=light href=https://twitter.com/_naa_4f data-chrome="noheader nofooter transparent noborders"> Tweets by manhhomienbienthuy </a> </div> </div> </div> <a href=# class="smooth-scroll back-to-top"> <i class="fa fa-arrow-circle-up fa-3x"></i> </a> </main> <footer> <div class=infos> <div class=wrapper> <div class=widget> <a href=/ title="manhhomienbienthuy's space" class=logo> <img alt="manhhomienbienthuy's space" src=/theme/images/logo_white.png> </a> <span class=right>I'm a hacker, enter my world...</span> </div><div class=widget> <p> Created with all my ♥ and soul, dedicated to my love, yunachan <p> Powered by <a href=http://blog.getpelican.com/ target=_blank>Pelican</a>, which takes great advantage of <a href=https://www.python.org/ target=_blank>Python</a> <p> This site content is licensed under a <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank> CC BY-NC-ND 4.0 </a> License. <p> Updated at <a target=_blank href="http://www.timeanddate.com/worldclock/fixedtime.html?iso=2019-06-20T02:42:55"> 2019-06-20 02:42:55 </a> </div><div class=widget> <p> Hosting by <a href=https://manhhomienbienthuy.bitbucket.io/ >Bitbucket</a> and <a href=https://manhhomienbienthuy.github.io/ >Github</a>, image hosting by <a href=https://manhhomienbienthuy.imgur.com/ target=_blank>imgur</a>, <a href=https://instagram.com/manhhomienbienthuy/ target=_blank>Instagram</a> and <a href=https://photos.google.com/ target=_blank>Google Photo</a> <p> Theme based on <a href=https://vanice-veethemes.blogspot.com/ target=_blank>Vanice theme</a>, icons from <a href=https://fontawesome.com/ target=_blank>Font Awesome</a>, comments powered by <a href=https://disqus.com/home/forums/manhhomienbienthuy/ target=_blank>Disqus</a> </div> </div> </div> <div class=credits> <div class=wrapper> <div class=left> <!--
          Regarding copyright, in general, standalone pages (as
          opposed to files generated as part of manuals) on the GNU
          web server should be under CC BY-ND 4.0.  Please do NOT
          change or remove this without talking with the webmasters or
          licensing team first.  Please make sure the copyright date
          is consistent with the document.  For web pages, it is ok to
          list just the latest year the document was modified, or
          published.

          If you wish to list earlier years, that is ok too.  Either
          "2001, 2002, 2003" or "2001-2003" are ok for specifying
          years, as long as each year in the range is in fact a
          copyrightable year, i.e., a year in which the document was
          published (including being publicly visible on the web or in
          a revision control system).
        --> Copyright © 2010-2019 <a href=/pages/about-me.html><strong>manhhomienbienthuy</strong></a>. All rights reserved. </div> <div class=right> <ul> <li><a href=/ >Home</a> <li><a href=/pages/about-me.html>About</a> <li><a href=# class=smooth-scroll>Top ↑</a> </ul> </div> </div> </div></footer> <script src=https://code.jquery.com/jquery-3.2.1.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js></script> <script src=//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js></script> <script src=/theme/js/vpyeu.min.js?d72c87bd></script> <script id=dsq-count-scr src=https://manhhomienbienthuy.disqus.com/count.js async></script>